# Ansible Workflows
# Managed by chezmoi - DO NOT EDIT DIRECTLY

# ==================================
# Ansible Development Workflows
# ==================================

{{ if or (and (hasKey . "preferences") (hasKey .preferences "enable_ansible") .preferences.enable_ansible) (and (hasKey . "enable_dev_tools") .enable_dev_tools) -}}
# Initialize a new Ansible project
ansible-init-project() {
  local project_name=$1
  local directory=${2:-"{{ if and (hasKey . "preferences") (hasKey .preferences "projects_dir") }}{{ .preferences.projects_dir }}{{ else }}$HOME/Projects{{ end }}/$project_name"}

  if [[ -z "$project_name" ]]; then
    echo "Usage: ansible-init-project <project-name> [directory]"
    echo "Example: ansible-init-project my-infra ~/Projects/my-infra"
    return 1
  fi

  _require_cmd "ansible" "pip install ansible" || return 1

  mkdir -p "$directory"
  cd "$directory" || return 1

  # Create recommended directory structure
  mkdir -p {inventories,roles,group_vars,host_vars,playbooks,library,filter_plugins,files,templates}

  cat > ansible.cfg << 'EOF'
[defaults]
inventory = ./inventories
roles_path = ./roles
library = ./library
filter_plugins = ./filter_plugins
host_key_checking = False
retry_files_enabled = False
# Adjust according to your needs
stdout_callback = yaml
bin_ansible_callbacks = True

[ssh_connection]
pipelining = True
ssh_args = -o ControlMaster=auto -o ControlPersist=60s -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no
EOF

  cat > inventories/hosts << 'EOF'
[local]
localhost ansible_connection=local

[development]
# Add development hosts here
# example-dev ansible_host=192.168.1.101

[staging]
# Add staging hosts here
# example-staging ansible_host=192.168.1.102

[production]
# Add production hosts here
# example-prod ansible_host=192.168.1.103

[all:vars]
ansible_ssh_user=root
# Add global variables here
EOF

  cat > playbooks/site.yml << 'EOF'
---
- name: Main playbook
  hosts: all
  become: true
  gather_facts: true

  tasks:
    - name: Ping servers
      ping:
      tags:
        - always
EOF

  cat > README.md << "EOF"
# Ansible Project: ${project_name}

## Overview
This is an Ansible project for managing infrastructure.

## Structure
- `inventories/`: Inventory files defining host groups
- `roles/`: Ansible roles used in this project
- `group_vars/`: Variables applied to groups of hosts
- `host_vars/`: Variables applied to specific hosts
- `playbooks/`: Playbook files
- `library/`: Custom modules
- `filter_plugins/`: Custom filter plugins
- `files/`: Static files to be deployed
- `templates/`: Jinja2 templates

## Usage
Run a playbook:
```
ansible-playbook playbooks/site.yml -i inventories/hosts
```

Run a playbook with specific tags:
```
ansible-playbook playbooks/site.yml -i inventories/hosts --tags "config,services"
```

Run a playbook in check mode (dry run):
```
ansible-playbook playbooks/site.yml -i inventories/hosts --check
```
EOF

  git init

  cat > .gitignore << 'EOF'
*.retry
*.pyc
__pycache__/
.venv/
.python-version
.idea/
.vscode/
*.log
.DS_Store
*~
*.swp
*.swo
EOF

  git add .
  git commit -m "Initial Ansible project setup"

  echo "Ansible project '$project_name' initialized successfully at $directory"
  echo "Next steps:"
  echo "1. Edit the inventory file: $directory/inventories/hosts"
  echo "2. Create roles with: ansible-galaxy init"
  echo "3. Edit playbooks/site.yml to add your automation"
}

# Create a new Ansible role
ansible-new-role() {
  local role_name=$1
  local directory=${2:-"./roles"}

  if [[ -z "$role_name" ]]; then
    echo "Usage: ansible-new-role <role-name> [directory]"
    echo "Example: ansible-new-role webserver ./roles"
    return 1
  fi

  _require_cmd "ansible-galaxy" "pip install ansible" || return 1

  mkdir -p "$directory"
  ansible-galaxy init "$directory/$role_name"

  echo "Ansible role '$role_name' created successfully at $directory/$role_name"
  echo "Next steps:"
  echo "1. Edit $directory/$role_name/tasks/main.yml to add your tasks"
  echo "2. Edit $directory/$role_name/defaults/main.yml to set default variables"
  echo "3. Add the role to your playbook"
}

# Run Ansible playbook with common options
ansible-run() {
  local playbook_path=$1
  local inventory=${2:-"inventories/hosts"}
  local options=${@:3}

  if [[ -z "$playbook_path" ]]; then
    echo "Usage: ansible-run <playbook-path> [inventory-path] [options]"
    echo "Example: ansible-run playbooks/site.yml inventories/production --limit web_servers"
    return 1
  fi

  if [[ ! -f "$playbook_path" ]]; then
    echo "Error: Playbook not found at $playbook_path"
    return 1
  fi

  if [[ ! -f "$inventory" ]]; then
    echo "Error: Inventory not found at $inventory"
    return 1
  fi

  ansible-playbook "$playbook_path" -i "$inventory" $options
}

# Create an encrypted Ansible vault file
ansible-new-vault() {
  local vault_file=$1
  local vault_dir=${2:-"./group_vars/all"}

  if [[ -z "$vault_file" ]]; then
    echo "Usage: ansible-new-vault <vault-name> [vault-directory]"
    echo "Example: ansible-new-vault secrets ./group_vars/production"
    return 1
  fi

  if [[ ! "$vault_file" =~ \.ya?ml$ ]]; then
    vault_file="${vault_file}.yml"
  fi

  mkdir -p "$vault_dir"

  ansible-vault create "$vault_dir/$vault_file"

  echo "Ansible vault file created at $vault_dir/$vault_file"
  echo "To edit this file: ansible-vault edit $vault_dir/$vault_file"
}

# Generate Ansible inventory file from static list or cloud provider
ansible-generate-inventory() {
  local output_file=${1:-"inventories/generated-hosts.yml"}
  local source=${2:-"manual"}

  mkdir -p "$(dirname "$output_file")"

  if [[ "$source" == "manual" ]]; then
    cat > "$output_file" << 'EOF'
---
all:
  children:
    web:
      hosts:
        web01:
          ansible_host: 192.168.1.101
          http_port: 80
        web02:
          ansible_host: 192.168.1.102
          http_port: 80
    db:
      hosts:
        db01:
          ansible_host: 192.168.1.201
          mysql_port: 3306
    dev:
      hosts:
        dev01:
          ansible_host: 192.168.1.150
    staging:
      children:
        web:
          hosts:
            web01:
        db:
          hosts:
            db01:
    production:
      children:
        web:
          hosts:
            web02:
  vars:
    ansible_user: admin
    ansible_ssh_private_key_file: ~/.ssh/id_rsa
EOF
  elif [[ "$source" == "aws" ]]; then
    _require_cmd "aws" "pip install awscli" || return 1

    cat > "$output_file" << 'EOF'
#!/bin/bash

# Dynamic inventory script for AWS EC2 instances
# Usage: ./this-script.sh --list
# or: ./this-script.sh --host [hostname]

if [[ "$1" == "--list" ]]; then
  aws ec2 describe-instances --query 'Reservations[*].Instances[*].[Tags[?Key==`Name`].Value[],InstanceId,PrivateIpAddress,PublicIpAddress,State.Name,Tags[?Key==`ansible_group`].Value[]]' --output json | \
  jq -r '[.[] | .[] | select(.[4]=="running") | {(.![0]): {"ansible_host": (.[3] // .[2]), "instance_id": .[1], "groups": (.[5] // ["ungrouped"])}}] | reduce .[] as $item ({}; . * $item) | {"_meta": {"hostvars": .}, "all": {"children": ["aws_ec2"]}, "aws_ec2": {"hosts": [keys[]]}}'
elif [[ "$1" == "--host" ]]; then
  # Return empty dict for --host
  echo "{}"
else
  echo "Usage: $0 --list or $0 --host [hostname]"
  exit 1
fi
EOF
    chmod +x "$output_file"
  elif [[ "$source" == "digitalocean" ]]; then
    cat > "$output_file" << 'EOF'
#!/bin/bash

# Dynamic inventory script for DigitalOcean droplets
# Usage: ./this-script.sh --list
# or: ./this-script.sh --host [hostname]

if [[ "$1" == "--list" ]]; then
  doctl compute droplet list --format Name,ID,PublicIPv4,Region,Tags --no-header | \
  awk '{print $1, $3, $5}' | \
  python -c '
import sys
import json

droplets = {}
groups = {}

for line in sys.stdin:
    parts = line.strip().split()
    if len(parts) >= 3:
        name = parts[0]
        ip = parts[1]
        tags = parts[2].split(",") if len(parts) > 2 else ["ungrouped"]

        droplets[name] = {"ansible_host": ip}

        for tag in tags:
            if tag not in groups:
                groups[tag] = {"hosts": []}
            groups[tag]["hosts"].append(name)

inventory = {"_meta": {"hostvars": droplets}}
for group, hosts in groups.items():
    inventory[group] = hosts

print(json.dumps(inventory))
'
elif [[ "$1" == "--host" ]]; then
  # Return empty dict for --host
  echo "{}"
else
  echo "Usage: $0 --list or $0 --host [hostname]"
  exit 1
fi
EOF
    chmod +x "$output_file"
  fi

  echo "Inventory file generated at $output_file"
  if [[ "$source" != "manual" ]]; then
    echo "This is a dynamic inventory script. Make it executable: chmod +x $output_file"
    echo "Use it with: ansible-playbook -i $output_file your-playbook.yml"
  fi
}

# Run Ansible adhoc command
ansible-adhoc() {
  local hosts=$1
  local module=${2:-"ping"}
  local args=${3:-""}
  local inventory=${4:-"inventories/hosts"}

  if [[ -z "$hosts" ]]; then
    echo "Usage: ansible-adhoc <hosts> [module] [args] [inventory]"
    echo "Example: ansible-adhoc webservers apt 'name=nginx state=latest' inventories/production"
    return 1
  fi

  if [[ ! -f "$inventory" ]]; then
    echo "Error: Inventory not found at $inventory"
    return 1
  fi

  if [[ -n "$args" ]]; then
    ansible "$hosts" -i "$inventory" -m "$module" -a "$args"
  else
    ansible "$hosts" -i "$inventory" -m "$module"
  fi
}

# Generate an Ansible inventory from running servers
ansible-scan-network() {
  local network=$1
  local output_file=${2:-"inventories/scanned-hosts.yml"}

  if [[ -z "$network" ]]; then
    echo "Usage: ansible-scan-network <network-cidr> [output-file]"
    echo "Example: ansible-scan-network 192.168.1.0/24 inventories/my-network.yml"
    return 1
  fi

  _require_cmd "nmap" "brew install nmap (macOS) or apt install nmap (Linux)" || return 1

  echo "Scanning network $network for hosts..."

  mkdir -p "$(dirname "$output_file")"

  local temp_file=$(mktemp)
  nmap -sn "$network" -oG "$temp_file"

  cat > "$output_file" << 'EOF'
---
all:
  children:
    discovered:
      hosts:
EOF

  grep "Status: Up" "$temp_file" | awk '{print $2}' | while read -r host; do
    echo "        host_${host//./_}:" >> "$output_file"
    echo "          ansible_host: $host" >> "$output_file"
  done

  cat >> "$output_file" << 'EOF'
  vars:
    ansible_user: root
EOF

  rm "$temp_file"

  echo "Inventory file created at $output_file with discovered hosts"
  echo "Edit the file to organize hosts into appropriate groups"
}

# Ansible playbook wizard - interactively create a playbook
ansible-playbook-wizard() {
  local playbook_name=$1

  if [[ -z "$playbook_name" ]]; then
    echo "Usage: ansible-playbook-wizard <playbook-name>"
    echo "Example: ansible-playbook-wizard deploy-web-app"
    return 1
  fi

  if [[ ! "$playbook_name" =~ \.ya?ml$ ]]; then
    playbook_name="${playbook_name}.yml"
  fi

  mkdir -p "playbooks"

  echo "Creating Ansible playbook: $playbook_name"

  read "target_hosts?Target hosts (e.g., all, webservers, db): "
  target_hosts=${target_hosts:-"all"}

  read "become_answer?Should tasks run with sudo/become? (y/n): "
  if [[ "$become_answer" =~ ^[Yy]$ ]]; then
    become="true"
  else
    become="false"
  fi

  read "facts_answer?Gather facts? (y/n): "
  if [[ "$facts_answer" =~ ^[Yy]$ ]]; then
    gather_facts="true"
  else
    gather_facts="false"
  fi

  cat > "playbooks/$playbook_name" << EOF
---
- name: ${playbook_name%.*} playbook
  hosts: $target_hosts
  become: $become
  gather_facts: $gather_facts

  vars:
    # Define variables here

  tasks:
    - name: Ensure system is updated
      apt:
        update_cache: yes
        upgrade: dist
      when: ansible_os_family == "Debian"
      tags:
        - setup
        - update

    # Add more tasks here

  handlers:
    - name: restart nginx
      service:
        name: nginx
        state: restarted
EOF

  echo "Playbook created at playbooks/$playbook_name"
  echo "Edit the file to add your tasks and customize as needed"
}
{{- end }}
