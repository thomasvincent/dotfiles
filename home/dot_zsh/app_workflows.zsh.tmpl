# App Integration Workflows
# Managed by chezmoi - DO NOT EDIT DIRECTLY

# ==================================
# GTD (Getting Things Done) Workflows
# ==================================

# GTD functions have been moved to platform-specific modules:
# - macos_gtd_workflows.zsh.tmpl (macOS native GTD with Notes, Reminders, Calendar, Mail)
# - google_gtd_workflows.zsh.tmpl (Google GTD with Gmail, Calendar, Keep, Tasks, Drive)
# - microsoft_gtd_workflows.zsh.tmpl (Microsoft 365 GTD with Outlook, To Do, OneNote)
#
# See those files for: gtd-capture, gtd-review, gtd-new-project, gtd-next, etc.

# ==================================
# Mail App Workflows
# ==================================

# Mail.app functions have been moved to macos_gtd_workflows.zsh.tmpl
# See that file for: mail-process, mail-new, mail-unread, mail-from-note

{{ if and (hasKey . "macos") .macos (hasKey . "enable_productivity") .enable_productivity -}}
# Flag important emails matching a search term (not in macos_gtd_workflows)
mail-flag-search() {
  local search_term=$1

  if [[ -z "$search_term" ]]; then
    echo "Usage: mail-flag-search <search-term>"
    echo "Searches for emails containing the search term and flags them"
    return 1
  fi

  osascript <<EOF
tell application "Mail"
  set matchingMessages to (messages of inbox whose subject contains "$search_term" or content contains "$search_term" and flagged is false)
  set messageCount to count of matchingMessages

  if messageCount is 0 then
    return "No matching messages found."
  end if

  repeat with aMessage in matchingMessages
    set flagged of aMessage to true
  end repeat

  return "Flagged " & messageCount & " messages containing '$search_term'."
end tell
EOF
}
{{- end }}

# ==================================
# Slack Workflows
# ==================================

{{ if and (hasKey . "enable_productivity") .enable_productivity -}}
# Send a Slack message via webhook
slack-send() {
  local webhook_url=$1
  local message=$2
  local channel=${3:-""}
  local username=${4:-"CLI Bot"}

  if [[ -z "$webhook_url" || -z "$message" ]]; then
    echo "Usage: slack-send <webhook-url> <message> [channel] [username]"
    echo "Example: slack-send https://hooks.slack.com/services/XXX/YYY/ZZZ \"Hello from CLI\" \"#general\" \"CLI Bot\""
    return 1
  fi

  local payload="{\"text\":\"$message\", \"username\":\"$username\""

  if [[ -n "$channel" ]]; then
    payload="$payload, \"channel\":\"$channel\""
  fi

  payload="$payload}"

  curl -X POST -H 'Content-type: application/json' --data "$payload" "$webhook_url"

  echo "Message sent to Slack"
}

# Open Slack and navigate to a channel
slack-open() {
  local channel=$1

  if [[ -z "$channel" ]]; then
    echo "Usage: slack-open <channel>"
    echo "Example: slack-open general"
    return 1
  fi

  if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS - Use AppleScript
    osascript <<EOF
tell application "Slack"
  activate
  tell application "System Events"
    keystroke "k" using {command down}
    delay 0.5
    keystroke "$channel"
    delay 0.5
    keystroke return
  end tell
end tell
EOF
    echo "Slack opened and navigated to #$channel"
  else
    # Linux/Other - Just open Slack
    if command -v slack >/dev/null 2>&1; then
      slack &
      echo "Slack opened. Please navigate to #$channel manually."
    else
      echo "Slack executable not found. Please install Slack or open it manually."
    fi
  fi
}

# Set Slack status
slack-status() {
  local status_text=$1
  local status_emoji=${2:-":speech_balloon:"}

  if [[ -z "$status_text" ]]; then
    echo "Usage: slack-status <status-text> [status-emoji]"
    echo "Example: slack-status \"In a meeting\" \":calendar:\""
    echo "Note: This function requires macOS and the Slack application."
    return 1
  fi

  if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS - Use AppleScript
    osascript <<EOF
tell application "Slack"
  activate
  tell application "System Events"
    keystroke "y" using {command down, shift down}
    delay 0.5
    keystroke "$status_text"
    delay 0.5
    keystroke tab
    keystroke "$status_emoji"
    delay 0.5
    keystroke return
  end tell
end tell
EOF
    echo "Slack status set to $status_text $status_emoji"
  else
    echo "This function is currently only supported on macOS."
  fi
}

# Create a Slack reminder from the command line
slack-remind() {
  local reminder_text=$1
  local time=$2

  if [[ -z "$reminder_text" || -z "$time" ]]; then
    echo "Usage: slack-remind <reminder-text> <time>"
    echo "Example: slack-remind \"Team meeting\" \"tomorrow at 10am\""
    echo "Note: This function requires macOS and the Slack application."
    return 1
  fi

  if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS - Use AppleScript
    osascript <<EOF
tell application "Slack"
  activate
  tell application "System Events"
    keystroke "/"
    delay 0.5
    keystroke "remind"
    delay 0.5
    keystroke space
    keystroke "me"
    delay 0.5
    keystroke space
    keystroke "$reminder_text"
    delay 0.5
    keystroke space
    keystroke "$time"
    delay 0.5
    keystroke return
  end tell
end tell
EOF
    echo "Slack reminder set: \"$reminder_text\" for $time"
  else
    echo "This function is currently only supported on macOS."
  fi
}
{{- end }}

# ==================================
# Microsoft Teams Workflows
# ==================================

{{ if and (hasKey . "macos") .macos (hasKey . "enable_productivity") .enable_productivity -}}
# Open Microsoft Teams and navigate to a channel
teams-open() {
  local team=$1
  local channel=${2:-"General"}

  if [[ -z "$team" ]]; then
    echo "Usage: teams-open <team-name> [channel-name]"
    echo "Example: teams-open \"Marketing Team\" General"
    return 1
  fi

  osascript <<EOF
tell application "Microsoft Teams"
  activate
end tell

-- Give Teams time to fully load
delay 2

tell application "System Events"
  tell process "Microsoft Teams"
    -- Use Command+F to open the search
    keystroke "f" using {command down}
    delay 1

    -- Type the team name
    keystroke "$team"
    delay 2

    -- Press Enter to select the team
    keystroke return
    delay 2

    -- If a channel is specified, try to navigate to it
    if "$channel" is not "General" then
      -- Use Command+F again to search within the team
      keystroke "f" using {command down}
      delay 1

      -- Type the channel name
      keystroke "$channel"
      delay 1

      -- Press Enter to select the channel
      keystroke return
    end if
  end tell
end tell
EOF

  echo "Microsoft Teams opened and navigated to $team > $channel"
}

# Start a new Teams meeting
teams-new-meeting() {
  osascript <<EOF
tell application "Microsoft Teams"
  activate
end tell

delay 1

tell application "System Events"
  tell process "Microsoft Teams"
    -- Click on the "New meeting" button
    keystroke "n" using {command down, shift down}
  end tell
end tell
EOF

  echo "Starting a new Microsoft Teams meeting"
}

# Set Teams status
teams-status() {
  local status=$1

  if [[ -z "$status" ]]; then
    echo "Usage: teams-status <status>"
    echo "Available statuses: available, busy, dnd, away, offline"
    return 1
  fi

  case "$status" in
    available|busy|dnd|away|offline)
      # Valid status
      ;;
    *)
      echo "Invalid status: $status"
      echo "Available statuses: available, busy, dnd, away, offline"
      return 1
      ;;
  esac

  osascript <<EOF
tell application "Microsoft Teams"
  activate
end tell

delay 1

tell application "System Events"
  tell process "Microsoft Teams"
    -- Click on profile picture (top right)
    keystroke "p" using {command down, shift down}
    delay 1

    -- Navigate to correct status option
    set statusText to "$status"

    if statusText is "available" then
      keystroke "1"
    else if statusText is "busy" then
      keystroke "2"
    else if statusText is "dnd" then
      keystroke "3"
    else if statusText is "away" then
      keystroke "4"
    else if statusText is "offline" then
      keystroke "5"
    end if
  end tell
end tell
EOF

  echo "Teams status set to: $status"
}
{{- end }}

# ==================================
# Gmail Workflows
# ==================================

# Gmail functions have been moved to google_gtd_workflows.zsh.tmpl
# See that file for: gmail-search, gmail-compose, gmail-filter

# ==================================
# Calendar Workflows
# ==================================

# macOS Calendar functions have been moved to macos_gtd_workflows.zsh.tmpl
# See that file for: calendar-today, calendar-create, calendar-list

{{ if and (hasKey . "macos") .macos (hasKey . "enable_productivity") .enable_productivity -}}
# Create a new Calendar event (calendar-new wrapper)
calendar-new() {
  local title=$1
  local start_date=$2
  local end_date=$3
  local location=${4:-""}
  local calendar=${5:-""}
  local all_day=${6:-"false"}

  if [[ -z "$title" || -z "$start_date" ]]; then
    echo "Usage: calendar-new <title> <start-date-time> [end-date-time] [location] [calendar] [all-day]"
    echo "Example: calendar-new \"Team Meeting\" \"2023-06-15 14:00\" \"2023-06-15 15:00\" \"Conference Room\" \"Work\" false"
    echo "Note: Dates should be in format YYYY-MM-DD HH:MM"
    echo "      For all-day events, use YYYY-MM-DD and set all-day to true"
    return 1
  fi

  # If end date is not provided, set it to 1 hour after start date
  if [[ -z "$end_date" ]]; then
    if [[ "$start_date" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
      # Start date is just a date (YYYY-MM-DD), assume all-day event
      end_date="$start_date"
      all_day="true"
    else
      # Start date includes time, set end date to 1 hour later
      if [[ "$OSTYPE" == "darwin"* ]]; then
        end_date=$(date -j -f "%Y-%m-%d %H:%M" -v+1H "$start_date" "+%Y-%m-%d %H:%M")
      else
        end_date=$(date -d "$start_date 1 hour" "+%Y-%m-%d %H:%M")
      fi
    fi
  fi

  osascript <<EOF
tell application "Calendar"
  set allDay to $all_day

  -- Convert date strings to date objects
  set startDate to (do shell script "date -j -f '%Y-%m-%d %H:%M' '$start_date' '+%Y-%m-%d %H:%M:%S'")
  set endDate to (do shell script "date -j -f '%Y-%m-%d %H:%M' '$end_date' '+%Y-%m-%d %H:%M:%S'")

  set startDate to date startDate
  set endDate to date endDate

  -- Determine which calendar to use
  if "$calendar" is not "" then
    set targetCalendar to calendar "$calendar"
  else
    set targetCalendar to default calendar
  end if

  -- Create the event
  tell targetCalendar
    make new event with properties {summary:"$title", start date:startDate, end date:endDate, location:"$location", allday event:allDay}
  end tell

  return "Created event: $title on " & name of targetCalendar
end tell
EOF
}

# Search Calendar events
calendar-search() {
  local search_term=$1
  local days=${2:-30}

  if [[ -z "$search_term" ]]; then
    echo "Usage: calendar-search <search-term> [days]"
    echo "Example: calendar-search \"meeting\" 7"
    echo "Searches for events containing the search term in the next N days (default: 30)"
    return 1
  fi

  osascript <<EOF
tell application "Calendar"
  set daysToSearch to $days
  set searchStart to current date
  set searchEnd to searchStart + (daysToSearch * days)

  set matchingEvents to {}
  repeat with c in calendars
    set calEvents to (events of c whose start date â‰¥ searchStart and start date < searchEnd)
    repeat with e in calEvents
      if summary of e contains "$search_term" or (location of e is not "" and location of e contains "$search_term") then
        set end of matchingEvents to e
      end if
    end repeat
  end repeat

  if (count of matchingEvents) > 0 then
    set output to "Events matching '$search_term' in the next $days days:" & return & "---------------------------------------------" & return

    -- Sort and format matching events
    set sortedEvents to {}
    repeat with e in matchingEvents
      set eventDate to start date of e
      set eventDateString to date string of eventDate
      set eventTime to time string of eventDate
      set eventTitle to summary of e
      set loc to location of e

      if loc is not "" then
        set eventInfo to eventDateString & " " & eventTime & " - " & eventTitle & " (" & loc & ")"
      else
        set eventInfo to eventDateString & " " & eventTime & " - " & eventTitle
      end if

      set end of sortedEvents to {eventDate, eventInfo}
    end repeat

    -- Sort events by date
    set sortedEvents to sortedEvents as list
    set results to {}

    repeat while (count of sortedEvents) > 0
      set earliest to item 1 of sortedEvents
      set earliestIndex to 1

      repeat with i from 1 to count of sortedEvents
        set this_event to item i of sortedEvents
        if item 1 of this_event < item 1 of earliest then
          set earliest to this_event
          set earliestIndex to i
        end if
      end repeat

      set end of results to item 2 of earliest
      set sortedEvents to items 1 thru (earliestIndex - 1) of sortedEvents & items (earliestIndex + 1) thru (count of sortedEvents) of sortedEvents
    end repeat

    repeat with r in results
      set output to output & r & return
    end repeat

    return output
  else
    return "No events matching '$search_term' found in the next $days days."
  end if
end tell
EOF
}
{{- end }}

# ==================================
# Google Calendar Workflows
# ==================================

# Google Calendar functions have been moved to google_gtd_workflows.zsh.tmpl
# See that file for: gcal-new, gcal-open, gcal-range, gcal-today

# ==================================
# Office365 Workflows
# ==================================

{{ if and (hasKey . "enable_productivity") .enable_productivity -}}
# Open Office365 apps
office365-open() {
  local app=$1

  if [[ -z "$app" ]]; then
    echo "Usage: office365-open <app>"
    echo "Available apps: outlook, word, excel, powerpoint, onenote, teams, onedrive"
    return 1
  fi

  local app_url=""

  case "$app" in
    outlook)
      app_url="https://outlook.office.com/mail/"
      ;;
    word)
      app_url="https://www.office.com/launch/word"
      ;;
    excel)
      app_url="https://www.office.com/launch/excel"
      ;;
    powerpoint)
      app_url="https://www.office.com/launch/powerpoint"
      ;;
    onenote)
      app_url="https://www.office.com/launch/onenote"
      ;;
    teams)
      app_url="https://teams.microsoft.com/"
      ;;
    onedrive)
      app_url="https://onedrive.live.com/"
      ;;
    *)
      echo "Invalid app: $app"
      echo "Available apps: outlook, word, excel, powerpoint, onenote, teams, onedrive"
      return 1
      ;;
  esac

  _open_url "$app_url"

  echo "Opening Office365 $app"
}

# Create a new document in Office365
office365-new() {
  local doc_type=$1

  if [[ -z "$doc_type" ]]; then
    echo "Usage: office365-new <document-type>"
    echo "Available document types: word, excel, powerpoint, onenote"
    return 1
  fi

  local doc_url=""

  case "$doc_type" in
    word|document)
      doc_url="https://www.office.com/launch/word/new"
      ;;
    excel|spreadsheet)
      doc_url="https://www.office.com/launch/excel/new"
      ;;
    powerpoint|presentation)
      doc_url="https://www.office.com/launch/powerpoint/new"
      ;;
    onenote|notebook)
      doc_url="https://www.office.com/launch/onenote/new"
      ;;
    *)
      echo "Invalid document type: $doc_type"
      echo "Available document types: word, excel, powerpoint, onenote"
      return 1
      ;;
  esac

  _open_url "$doc_url"

  echo "Creating new Office365 $doc_type document"
}

# Compose a new email in Outlook
outlook-compose() {
  local to=$1
  local subject=$2
  local body=$3

  if [[ -z "$to" ]]; then
    echo "Usage: outlook-compose <to> [subject] [body]"
    echo "Example: outlook-compose \"user@example.com\" \"Meeting Tomorrow\" \"Hi, let's meet tomorrow.\""
    return 1
  fi

  to=$(_url_encode "$to")
  subject=$(_url_encode "$subject")
  body=$(_url_encode "$body")

  local outlook_url="https://outlook.office.com/mail/deeplink/compose?to=${to}&subject=${subject}&body=${body}"

  _open_url "$outlook_url"

  echo "Creating email to $to in Outlook"
}

# Open OneDrive folder
onedrive-open() {
  local folder_path=$1

  if [[ -z "$folder_path" ]]; then
    local onedrive_url="https://onedrive.live.com/"
  else
    folder_path=$(_url_encode "$folder_path")

    # Note: This is an approximation as the actual URL structure depends on folder IDs
    local onedrive_url="https://onedrive.live.com/?id=root&cid=root&qt=sharedby&path=${folder_path}"
  fi

  _open_url "$onedrive_url"

  if [[ -z "$folder_path" ]]; then
    echo "Opening OneDrive root folder"
  else
    echo "Opening OneDrive folder: $folder_path"
  fi
}
{{- end }}
