# App Integration Workflows
# Managed by chezmoi - DO NOT EDIT DIRECTLY

# ==================================
# GTD (Getting Things Done) Workflows
# ==================================

{{ if and (eq .macos true) (not .minimal) -}}

# GTD Inbox Capture
gtd-capture() {
  local note_text=$1
  local inbox_folder="{{ .preferences.gtd_inbox_folder | default \"GTD/Inbox\" }}"
  
  if [[ -z "$note_text" ]]; then
    echo "Usage: gtd-capture <note-text>"
    echo "Captures a quick note to your GTD inbox"
    return 1
  fi
  
  # First try to use Apple Notes app (if on macOS)
  if [[ "$USE_MACOS_NOTES" == "true" ]]; then
    # Make sure the folder exists in Notes
    osascript <<EOF > /dev/null 2>&1
tell application "Notes"
  set folderExists to false
  repeat with aFolder in folders
    if name of aFolder is "$inbox_folder" then
      set folderExists to true
      exit repeat
    end if
  end repeat
  
  if not folderExists then
    make new folder with properties {name:"$inbox_folder"}
  end if
end tell
EOF
    
    # Add the note to the folder
    local date=$(date '+%Y-%m-%d %H:%M')
    local title="Inbox: ${note_text:0:50}..."
    
    osascript <<EOF
tell application "Notes"
  tell folder "$inbox_folder"
    make new note with properties {name:"$title", body:"# Inbox Item\n\nCreated: $date\n\n$note_text\n\nTags: #inbox"}
  end tell
end tell
EOF
    
    echo "Note captured in Apple Notes ($inbox_folder folder)"
    return 0
  fi
  
  # Fallback to reminders if Notes is not enabled but Reminders is
  if [[ "$USE_MACOS_REMINDERS" == "true" ]]; then
    local list="Inbox"
    
    # Make sure the list exists in Reminders
    osascript <<EOF > /dev/null 2>&1
tell application "Reminders"
  if not (exists list "$list") then
    make new list with properties {name:"$list"}
  end if
end tell
EOF
    
    # Add the reminder to the list
    osascript <<EOF
tell application "Reminders"
  tell list "$list"
    make new reminder with properties {name:"$note_text", body:"Created $(date '+%Y-%m-%d %H:%M')"}
  end tell
end tell
EOF
    
    echo "Note captured in Reminders (Inbox list)"
    return 0
  fi
  
  # Fallback to text file
  local inbox_file="{{ .preferences.gtd_inbox_file | default \"$HOME/.gtd/inbox.md\" }}"
  mkdir -p "$(dirname "$inbox_file")"
  
  # Append to inbox file
  local date=$(date '+%Y-%m-%d %H:%M')
  echo "## Inbox Item: $date" >> "$inbox_file"
  echo "" >> "$inbox_file"
  echo "$note_text" >> "$inbox_file"
  echo "" >> "$inbox_file"
  echo "---" >> "$inbox_file"
  echo "" >> "$inbox_file"
  
  echo "Note captured in $inbox_file"
}

# GTD Weekly Review
gtd-review() {
  local review_template="{{ .preferences.gtd_templates_dir | default \"$HOME/.gtd/templates\" }}/weekly-review.md"
  local review_file="$HOME/Desktop/GTD-Weekly-Review-$(date '+%Y-%m-%d').md"
  
  # Create the review template if it doesn't exist
  if [[ ! -f "$review_template" ]]; then
    mkdir -p "$(dirname "$review_template")"
    cat > "$review_template" << 'EOF'
# GTD Weekly Review - {{DATE}}

## Collect Loose Papers and Materials
- [ ] Physical inbox processed
- [ ] Desk cleared
- [ ] Notes from meetings processed

## Process Notes
- [ ] Apple Notes inbox processed
- [ ] Physical notes processed
- [ ] Other digital notes processed

## Process Email Inboxes
- [ ] Work email processed to zero
- [ ] Personal email processed to zero

## Empty Your Head
- [ ] Capture any new tasks or projects

## Review Action Lists
- [ ] Review Next Actions lists
- [ ] Review Waiting For list
- [ ] Review Project lists
- [ ] Review Someday/Maybe list
- [ ] Review Calendar

## Review Goals
- [ ] Review short-term goals
- [ ] Review annual goals
- [ ] Review 3-5 year goals

## Planning
- [ ] Choose key tasks for next week
- [ ] Schedule time blocks for important work

## Notes from this review:



EOF
  fi
  
  # Create a new review file from the template
  cp "$review_template" "$review_file"
  
  # Replace {{DATE}} with the current date
  sed -i '' "s/{{DATE}}/$(date '+%Y-%m-%d')/g" "$review_file"
  
  # Open the review file
  if [[ "$USE_MACOS_NOTES" == "true" ]]; then
    # Create a note from the file
    local content=$(<"$review_file")
    
    osascript <<EOF
tell application "Notes"
  make new note with properties {name:"Weekly Review $(date '+%Y-%m-%d')", body:"$content"}
  show note 1
  activate
end tell
EOF
    
    # Remove the temp file since it's now in Notes
    rm "$review_file"
    echo "Weekly Review template opened in Apple Notes"
  else
    # Open with default editor
    {{ if eq .preferences.editor "vscode" -}}
    code "$review_file"
    {{ else if eq .preferences.editor "vim" -}}
    vim "$review_file"
    {{ else if eq .preferences.editor "neovim" -}}
    nvim "$review_file"
    {{ else if eq .preferences.editor "emacs" -}}
    emacs "$review_file"
    {{ else -}}
    open "$review_file"
    {{ end -}}
    
    echo "Weekly Review template created at $review_file"
  fi
}

# Create project template for GTD
gtd-new-project() {
  local project_name=$1
  local project_folder="{{ .preferences.gtd_projects_folder | default \"GTD/Projects\" }}"
  
  if [[ -z "$project_name" ]]; then
    echo "Usage: gtd-new-project <project-name>"
    echo "Creates a new GTD project template"
    return 1
  fi
  
  # Create a project note in Apple Notes if available
  if [[ "$USE_MACOS_NOTES" == "true" ]]; then
    # Make sure the folder exists
    osascript <<EOF > /dev/null 2>&1
tell application "Notes"
  set folderExists to false
  repeat with aFolder in folders
    if name of aFolder is "$project_folder" then
      set folderExists to true
      exit repeat
    end if
  end repeat
  
  if not folderExists then
    make new folder with properties {name:"$project_folder"}
  end if
end tell
EOF
    
    # Create the project note with template
    local date=$(date '+%Y-%m-%d')
    local template="# Project: $project_name

Created: $date
Status: Active

## Outcome
What is the successful outcome of this project?

## Purpose
Why am I doing this project?

## Next Actions
- [ ] 
- [ ] 
- [ ] 

## Waiting For
- [ ] 

## Reference Material
* 

## Notes
"
    
    osascript <<EOF
tell application "Notes"
  tell folder "$project_folder"
    make new note with properties {name:"Project: $project_name", body:"$template"}
  end tell
  show note "Project: $project_name" in folder "$project_folder"
  activate
end tell
EOF
    
    echo "Project note for '$project_name' created in Apple Notes ($project_folder folder)"
    return 0
  fi
  
  # Fallback to text file
  local projects_dir="{{ .preferences.gtd_projects_dir | default \"$HOME/.gtd/projects\" }}"
  mkdir -p "$projects_dir"
  
  local project_file="$projects_dir/${project_name// /_}.md"
  
  # Create project file
  cat > "$project_file" << EOF
# Project: $project_name

Created: $(date '+%Y-%m-%d')
Status: Active

## Outcome
What is the successful outcome of this project?

## Purpose
Why am I doing this project?

## Next Actions
- [ ] 
- [ ] 
- [ ] 

## Waiting For
- [ ] 

## Reference Material
* 

## Notes

EOF
  
  # Open the project file
  {{ if eq .preferences.editor "vscode" -}}
  code "$project_file"
  {{ else if eq .preferences.editor "vim" -}}
  vim "$project_file"
  {{ else if eq .preferences.editor "neovim" -}}
  nvim "$project_file"
  {{ else if eq .preferences.editor "emacs" -}}
  emacs "$project_file"
  {{ else -}}
  open "$project_file"
  {{ end -}}
  
  echo "Project file for '$project_name' created at $project_file"
}

# List GTD next actions
gtd-next() {
  local context=$1
  
  # Try to use macOS Reminders if available
  if [[ "$USE_MACOS_REMINDERS" == "true" ]]; then
    # Different behavior based on whether a context is specified
    if [[ -z "$context" ]]; then
      # List all contexts with counts
      echo "GTD Next Actions by Context:"
      echo "==========================="
      
      osascript <<EOF | sort
tell application "Reminders"
  set allLists to name of lists
  set output to ""
  repeat with listName in allLists
    if listName starts with "@" then
      set theList to list listName
      set incompleteCount to (count of (reminders in theList whose completed is false))
      if incompleteCount > 0 then
        set output to output & listName & " (" & incompleteCount & ")\n"
      end if
    end if
  end repeat
  return output
end tell
EOF
      echo ""
      echo "Use 'gtd-next @context' to see tasks for a specific context"
    else
      # Show reminders for the specific context
      echo "Next Actions for $context:"
      echo "======================="
      
      osascript <<EOF | awk '{print "- " $0}'
tell application "Reminders"
  if not (exists list "$context") then
    return "Context list '$context' not found. Available contexts start with @."
  end if
  
  set output to ""
  set theList to list "$context"
  set theReminders to (reminders in theList whose completed is false)
  repeat with r in theReminders
    set output to output & name of r & "\n"
  end repeat
  return output
end tell
EOF
    fi
    
    return 0
  fi
  
  # Fallback to text files
  local next_actions_file="{{ .preferences.gtd_next_actions_file | default \"$HOME/.gtd/next-actions.md\" }}"
  
  if [[ ! -f "$next_actions_file" ]]; then
    echo "Next actions file not found at $next_actions_file"
    echo "You can create it with your editor or by using gtd-capture"
    return 1
  fi
  
  if [[ -z "$context" ]]; then
    # Show all contexts (lines starting with "## @")
    echo "GTD Next Actions by Context:"
    echo "==========================="
    grep -E "^## @" "$next_actions_file" | sed 's/^## //'
  else
    # Show items for the specific context
    echo "Next Actions for $context:"
    echo "======================="
    
    # Extract the section for the context and then all list items until the next section
    awk '/^## '"$context"'$/{flag=1; next} /^## /{flag=0} flag' "$next_actions_file" | grep "^\-" | sed 's/^\- \[ \]/[ ] /'
  fi
}
{{- end }}

# ==================================
# Mail App Workflows
# ==================================

{{ if and (eq .macos true) (eq .enable_productivity true) -}}
# Process Mail.app inbox using keyboard shortcuts
mail-process() {
  # Open Mail.app and focus on inbox
  osascript <<EOF
tell application "Mail"
  activate
  set selected mailboxes of message viewer 1 to {inbox}
end tell
EOF
  
  echo "Mail.app opened and focused on inbox."
  echo ""
  echo "Keyboard Shortcuts for Processing:"
  echo "⌘+A: Select all messages"
  echo "⌘+Delete: Delete selected messages"
  echo "⌘+Shift+A: Archive selected messages"
  echo "⌘+Shift+L: Flag selected messages"
  echo "⌘+Shift+J: Mark as Junk"
  echo "Spacebar: Preview message"
  echo ""
  echo "Close this terminal with ⌘+W when finished processing email."
}

# Create a new email
mail-new() {
  local recipient=$1
  local subject=${2:-""}
  local body=${3:-""}
  
  if [[ -z "$recipient" ]]; then
    echo "Usage: mail-new <recipient> [subject] [body]"
    echo "Example: mail-new user@example.com \"Meeting Tomorrow\" \"Hi, let's meet tomorrow.\""
    return 1
  fi
  
  osascript <<EOF
tell application "Mail"
  set newMessage to make new outgoing message with properties {subject:"$subject", content:"$body", visible:true}
  tell newMessage
    make new to recipient at end of to recipients with properties {address:"$recipient"}
  end tell
  activate
end tell
EOF
  
  echo "New email created to $recipient"
}

# Count unread emails
mail-unread() {
  osascript <<EOF
tell application "Mail"
  set unreadCount to unread count of inbox
  return "You have " & unreadCount & " unread messages in your inbox."
end tell
EOF
}

# Flag important emails matching a search term
mail-flag-search() {
  local search_term=$1
  
  if [[ -z "$search_term" ]]; then
    echo "Usage: mail-flag-search <search-term>"
    echo "Searches for emails containing the search term and flags them"
    return 1
  fi
  
  osascript <<EOF
tell application "Mail"
  set matchingMessages to (messages of inbox whose subject contains "$search_term" or content contains "$search_term" and flagged is false)
  set messageCount to count of matchingMessages
  
  if messageCount is 0 then
    return "No matching messages found."
  end if
  
  repeat with aMessage in matchingMessages
    set flagged of aMessage to true
  end repeat
  
  return "Flagged " & messageCount & " messages containing '$search_term'."
end tell
EOF
}

# Create an email draft from notes
mail-from-note() {
  local note_title=$1
  
  if [[ ! "$USE_MACOS_NOTES" == "true" ]]; then
    echo "This command requires macOS Notes integration to be enabled."
    return 1
  fi
  
  if [[ -z "$note_title" ]]; then
    echo "Usage: mail-from-note <note-title>"
    echo "Creates an email draft from a note in Apple Notes"
    return 1
  fi
  
  osascript <<EOF
tell application "Notes"
  set noteFound to false
  set noteContent to ""
  set noteTitle to ""
  
  repeat with aNote in notes
    if name of aNote contains "$note_title" then
      set noteContent to body of aNote
      set noteTitle to name of aNote
      set noteFound to true
      exit repeat
    end if
  end repeat
  
  if not noteFound then
    return "Note '$note_title' not found."
  end if
  
  tell application "Mail"
    set newMessage to make new outgoing message with properties {subject:noteTitle, content:noteContent, visible:true}
    activate
  end tell
  
  return "Created new email draft from note: " & noteTitle
end tell
EOF
}
{{- end }}

# ==================================
# Slack Workflows
# ==================================

{{ if (eq .enable_productivity true) -}}
# Send a Slack message via webhook
slack-send() {
  local webhook_url=$1
  local message=$2
  local channel=${3:-""}
  local username=${4:-"CLI Bot"}
  
  if [[ -z "$webhook_url" || -z "$message" ]]; then
    echo "Usage: slack-send <webhook-url> <message> [channel] [username]"
    echo "Example: slack-send https://hooks.slack.com/services/XXX/YYY/ZZZ \"Hello from CLI\" \"#general\" \"CLI Bot\""
    return 1
  fi
  
  # Build the JSON payload
  local payload="{\"text\":\"$message\", \"username\":\"$username\""
  
  if [[ -n "$channel" ]]; then
    payload="$payload, \"channel\":\"$channel\""
  fi
  
  payload="$payload}"
  
  # Send the message
  curl -X POST -H 'Content-type: application/json' --data "$payload" "$webhook_url"
  
  echo "Message sent to Slack"
}

# Open Slack and navigate to a channel
slack-open() {
  local channel=$1
  
  if [[ -z "$channel" ]]; then
    echo "Usage: slack-open <channel>"
    echo "Example: slack-open general"
    return 1
  fi
  
  if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS - Use AppleScript
    osascript <<EOF
tell application "Slack"
  activate
  tell application "System Events"
    keystroke "k" using {command down}
    delay 0.5
    keystroke "$channel"
    delay 0.5
    keystroke return
  end tell
end tell
EOF
    echo "Slack opened and navigated to #$channel"
  else
    # Linux/Other - Just open Slack
    if command -v slack >/dev/null 2>&1; then
      slack &
      echo "Slack opened. Please navigate to #$channel manually."
    else
      echo "Slack executable not found. Please install Slack or open it manually."
    fi
  fi
}

# Set Slack status
slack-status() {
  local status_text=$1
  local status_emoji=${2:-":speech_balloon:"}
  
  if [[ -z "$status_text" ]]; then
    echo "Usage: slack-status <status-text> [status-emoji]"
    echo "Example: slack-status \"In a meeting\" \":calendar:\""
    echo "Note: This function requires macOS and the Slack application."
    return 1
  fi
  
  if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS - Use AppleScript
    osascript <<EOF
tell application "Slack"
  activate
  tell application "System Events"
    keystroke "y" using {command down, shift down}
    delay 0.5
    keystroke "$status_text"
    delay 0.5
    keystroke tab
    keystroke "$status_emoji"
    delay 0.5
    keystroke return
  end tell
end tell
EOF
    echo "Slack status set to $status_text $status_emoji"
  else
    echo "This function is currently only supported on macOS."
  fi
}

# Create a Slack reminder from the command line
slack-remind() {
  local reminder_text=$1
  local time=$2
  
  if [[ -z "$reminder_text" || -z "$time" ]]; then
    echo "Usage: slack-remind <reminder-text> <time>"
    echo "Example: slack-remind \"Team meeting\" \"tomorrow at 10am\""
    echo "Note: This function requires macOS and the Slack application."
    return 1
  fi
  
  if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS - Use AppleScript
    osascript <<EOF
tell application "Slack"
  activate
  tell application "System Events"
    keystroke "/"
    delay 0.5
    keystroke "remind"
    delay 0.5
    keystroke space
    keystroke "me"
    delay 0.5
    keystroke space
    keystroke "$reminder_text"
    delay 0.5
    keystroke space
    keystroke "$time"
    delay 0.5
    keystroke return
  end tell
end tell
EOF
    echo "Slack reminder set: \"$reminder_text\" for $time"
  else
    echo "This function is currently only supported on macOS."
  fi
}
{{- end }}

# ==================================
# Microsoft Teams Workflows
# ==================================

{{ if and (eq .macos true) (eq .enable_productivity true) -}}
# Open Microsoft Teams and navigate to a channel
teams-open() {
  local team=$1
  local channel=${2:-"General"}
  
  if [[ -z "$team" ]]; then
    echo "Usage: teams-open <team-name> [channel-name]"
    echo "Example: teams-open \"Marketing Team\" General"
    return 1
  fi
  
  osascript <<EOF
tell application "Microsoft Teams"
  activate
end tell

-- Give Teams time to fully load
delay 2

tell application "System Events"
  tell process "Microsoft Teams"
    -- Use Command+F to open the search
    keystroke "f" using {command down}
    delay 1
    
    -- Type the team name
    keystroke "$team"
    delay 2
    
    -- Press Enter to select the team
    keystroke return
    delay 2
    
    -- If a channel is specified, try to navigate to it
    if "$channel" is not "General" then
      -- Use Command+F again to search within the team
      keystroke "f" using {command down}
      delay 1
      
      -- Type the channel name
      keystroke "$channel"
      delay 1
      
      -- Press Enter to select the channel
      keystroke return
    end if
  end tell
end tell
EOF
  
  echo "Microsoft Teams opened and navigated to $team > $channel"
}

# Start a new Teams meeting
teams-new-meeting() {
  osascript <<EOF
tell application "Microsoft Teams"
  activate
end tell

delay 1

tell application "System Events"
  tell process "Microsoft Teams"
    -- Click on the "New meeting" button
    keystroke "n" using {command down, shift down}
  end tell
end tell
EOF
  
  echo "Starting a new Microsoft Teams meeting"
}

# Set Teams status
teams-status() {
  local status=$1
  
  if [[ -z "$status" ]]; then
    echo "Usage: teams-status <status>"
    echo "Available statuses: available, busy, dnd, away, offline"
    return 1
  fi
  
  case "$status" in
    available|busy|dnd|away|offline)
      # Valid status
      ;;
    *)
      echo "Invalid status: $status"
      echo "Available statuses: available, busy, dnd, away, offline"
      return 1
      ;;
  esac
  
  osascript <<EOF
tell application "Microsoft Teams"
  activate
end tell

delay 1

tell application "System Events"
  tell process "Microsoft Teams"
    -- Click on profile picture (top right)
    keystroke "p" using {command down, shift down}
    delay 1
    
    -- Navigate to correct status option
    set statusText to "$status"
    
    if statusText is "available" then
      keystroke "1"
    else if statusText is "busy" then
      keystroke "2"
    else if statusText is "dnd" then
      keystroke "3"
    else if statusText is "away" then
      keystroke "4"
    else if statusText is "offline" then
      keystroke "5"
    end if
  end tell
end tell
EOF
  
  echo "Teams status set to: $status"
}
{{- end }}

# ==================================
# Gmail Workflows
# ==================================

{{ if (eq .enable_productivity true) -}}
# Open Gmail with search
gmail-search() {
  local search_query=$1
  
  if [[ -z "$search_query" ]]; then
    echo "Usage: gmail-search <search-query>"
    echo "Example: gmail-search \"from:example.com after:2023/01/01\""
    return 1
  fi
  
  # URL encode the search query
  local encoded_query=$(python3 -c "import urllib.parse; print(urllib.parse.quote('''$search_query'''))")
  
  # Open Gmail with the search query
  local gmail_url="https://mail.google.com/mail/u/0/#search/${encoded_query}"
  
  if [[ "$OSTYPE" == "darwin"* ]]; then
    open "$gmail_url"
  else
    xdg-open "$gmail_url" &> /dev/null
  fi
  
  echo "Opening Gmail with search: $search_query"
}

# Create a Gmail draft with mailto
gmail-compose() {
  local to=$1
  local subject=$2
  local body=$3
  
  if [[ -z "$to" ]]; then
    echo "Usage: gmail-compose <to> [subject] [body]"
    echo "Example: gmail-compose \"user@example.com\" \"Meeting tomorrow\" \"Hi, let's meet tomorrow.\""
    return 1
  fi
  
  # URL encode the parameters
  local encoded_subject=""
  local encoded_body=""
  
  if [[ -n "$subject" ]]; then
    encoded_subject=$(python3 -c "import urllib.parse; print(urllib.parse.quote('''$subject'''))")
  fi
  
  if [[ -n "$body" ]]; then
    encoded_body=$(python3 -c "import urllib.parse; print(urllib.parse.quote('''$body'''))")
  fi
  
  # Create the mailto URL
  local mailto_url="mailto:${to}?subject=${encoded_subject}&body=${encoded_body}"
  
  # Open the mailto URL
  if [[ "$OSTYPE" == "darwin"* ]]; then
    open "$mailto_url"
  else
    xdg-open "$mailto_url" &> /dev/null
  fi
  
  echo "Creating email to $to"
}

# Open Gmail with predefined filters
gmail-filter() {
  local filter=$1
  
  if [[ -z "$filter" ]]; then
    echo "Usage: gmail-filter <filter>"
    echo "Available filters: unread, starred, important, sent, drafts, spam, trash"
    return 1
  fi
  
  local gmail_url=""
  
  case "$filter" in
    unread)
      gmail_url="https://mail.google.com/mail/u/0/#search/is%3Aunread"
      ;;
    starred)
      gmail_url="https://mail.google.com/mail/u/0/#starred"
      ;;
    important)
      gmail_url="https://mail.google.com/mail/u/0/#imp"
      ;;
    sent)
      gmail_url="https://mail.google.com/mail/u/0/#sent"
      ;;
    drafts)
      gmail_url="https://mail.google.com/mail/u/0/#drafts"
      ;;
    spam)
      gmail_url="https://mail.google.com/mail/u/0/#spam"
      ;;
    trash)
      gmail_url="https://mail.google.com/mail/u/0/#trash"
      ;;
    *)
      echo "Invalid filter: $filter"
      echo "Available filters: unread, starred, important, sent, drafts, spam, trash"
      return 1
      ;;
  esac
  
  # Open Gmail with the filter
  if [[ "$OSTYPE" == "darwin"* ]]; then
    open "$gmail_url"
  else
    xdg-open "$gmail_url" &> /dev/null
  fi
  
  echo "Opening Gmail with filter: $filter"
}
{{- end }}

# ==================================
# Calendar Workflows
# ==================================

{{ if and (eq .macos true) (eq .enable_productivity true) -}}
# Create a new Calendar event
calendar-new() {
  local title=$1
  local start_date=$2
  local end_date=$3
  local location=${4:-""}
  local calendar=${5:-""}
  local all_day=${6:-"false"}
  
  if [[ -z "$title" || -z "$start_date" ]]; then
    echo "Usage: calendar-new <title> <start-date-time> [end-date-time] [location] [calendar] [all-day]"
    echo "Example: calendar-new \"Team Meeting\" \"2023-06-15 14:00\" \"2023-06-15 15:00\" \"Conference Room\" \"Work\" false"
    echo "Note: Dates should be in format YYYY-MM-DD HH:MM"
    echo "      For all-day events, use YYYY-MM-DD and set all-day to true"
    return 1
  fi
  
  # If end date is not provided, set it to 1 hour after start date
  if [[ -z "$end_date" ]]; then
    # Parse the start date to determine format
    if [[ "$start_date" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
      # Start date is just a date (YYYY-MM-DD), assume all-day event
      end_date="$start_date"
      all_day="true"
    else
      # Start date includes time, set end date to 1 hour later
      if [[ "$OSTYPE" == "darwin"* ]]; then
        end_date=$(date -j -f "%Y-%m-%d %H:%M" -v+1H "$start_date" "+%Y-%m-%d %H:%M")
      else
        end_date=$(date -d "$start_date 1 hour" "+%Y-%m-%d %H:%M")
      fi
    fi
  fi
  
  # Create the Calendar event
  osascript <<EOF
tell application "Calendar"
  set allDay to $all_day
  
  -- Convert date strings to date objects
  set startDate to (do shell script "date -j -f '%Y-%m-%d %H:%M' '$start_date' '+%Y-%m-%d %H:%M:%S'")
  set endDate to (do shell script "date -j -f '%Y-%m-%d %H:%M' '$end_date' '+%Y-%m-%d %H:%M:%S'")
  
  set startDate to date startDate
  set endDate to date endDate
  
  -- Determine which calendar to use
  if "$calendar" is not "" then
    set targetCalendar to calendar "$calendar"
  else
    set targetCalendar to default calendar
  end if
  
  -- Create the event
  tell targetCalendar
    make new event with properties {summary:"$title", start date:startDate, end date:endDate, location:"$location", allday event:allDay}
  end tell
  
  return "Created event: $title on " & name of targetCalendar
end tell
EOF
}

# List today's Calendar events
calendar-today() {
  osascript <<EOF
tell application "Calendar"
  set todayStart to current date
  set time of todayStart to 0
  set todayEnd to todayStart + (1 * days)
  
  set todayEvents to {}
  repeat with c in calendars
    set calEvents to (events of c whose start date ≥ todayStart and start date < todayEnd)
    set todayEvents to todayEvents & calEvents
  end repeat
  
  -- Sort events by start time
  set sortedEvents to {}
  repeat with e in todayEvents
    set eventStartDate to start date of e
    set eventTime to time string of eventStartDate
    set eventTitle to summary of e
    set loc to location of e
    if loc is not "" then
      set eventInfo to eventTime & " - " & eventTitle & " (" & loc & ")"
    else
      set eventInfo to eventTime & " - " & eventTitle
    end if
    set end of sortedEvents to {eventStartDate, eventInfo}
  end repeat
  
  set sortedEvents to sortedEvents as list
  set results to {}
  
  -- Sort events by start time
  repeat while (count of sortedEvents) > 0
    set earliest to item 1 of sortedEvents
    set earliestIndex to 1
    
    repeat with i from 1 to count of sortedEvents
      set this_event to item i of sortedEvents
      if item 1 of this_event < item 1 of earliest then
        set earliest to this_event
        set earliestIndex to i
      end if
    end repeat
    
    set end of results to item 2 of earliest
    set sortedEvents to items 1 thru (earliestIndex - 1) of sortedEvents & items (earliestIndex + 1) thru (count of sortedEvents) of sortedEvents
  end repeat
  
  if (count of results) > 0 then
    set output to "Today's Events:" & return & "----------------" & return
    repeat with r in results
      set output to output & r & return
    end repeat
    return output
  else
    return "No events scheduled for today."
  end if
end tell
EOF
}

# Search Calendar events
calendar-search() {
  local search_term=$1
  local days=${2:-30}
  
  if [[ -z "$search_term" ]]; then
    echo "Usage: calendar-search <search-term> [days]"
    echo "Example: calendar-search \"meeting\" 7"
    echo "Searches for events containing the search term in the next N days (default: 30)"
    return 1
  fi
  
  osascript <<EOF
tell application "Calendar"
  set daysToSearch to $days
  set searchStart to current date
  set searchEnd to searchStart + (daysToSearch * days)
  
  set matchingEvents to {}
  repeat with c in calendars
    set calEvents to (events of c whose start date ≥ searchStart and start date < searchEnd)
    repeat with e in calEvents
      if summary of e contains "$search_term" or (location of e is not "" and location of e contains "$search_term") then
        set end of matchingEvents to e
      end if
    end repeat
  end repeat
  
  if (count of matchingEvents) > 0 then
    set output to "Events matching '$search_term' in the next $days days:" & return & "---------------------------------------------" & return
    
    -- Sort and format matching events
    set sortedEvents to {}
    repeat with e in matchingEvents
      set eventDate to start date of e
      set eventDateString to date string of eventDate
      set eventTime to time string of eventDate
      set eventTitle to summary of e
      set loc to location of e
      
      if loc is not "" then
        set eventInfo to eventDateString & " " & eventTime & " - " & eventTitle & " (" & loc & ")"
      else
        set eventInfo to eventDateString & " " & eventTime & " - " & eventTitle
      end if
      
      set end of sortedEvents to {eventDate, eventInfo}
    end repeat
    
    -- Sort events by date
    set sortedEvents to sortedEvents as list
    set results to {}
    
    repeat while (count of sortedEvents) > 0
      set earliest to item 1 of sortedEvents
      set earliestIndex to 1
      
      repeat with i from 1 to count of sortedEvents
        set this_event to item i of sortedEvents
        if item 1 of this_event < item 1 of earliest then
          set earliest to this_event
          set earliestIndex to i
        end if
      end repeat
      
      set end of results to item 2 of earliest
      set sortedEvents to items 1 thru (earliestIndex - 1) of sortedEvents & items (earliestIndex + 1) thru (count of sortedEvents) of sortedEvents
    end repeat
    
    repeat with r in results
      set output to output & r & return
    end repeat
    
    return output
  else
    return "No events matching '$search_term' found in the next $days days."
  end if
end tell
EOF
}
{{- end }}

# ==================================
# Google Calendar Workflows
# ==================================

{{ if (eq .enable_productivity true) -}}
# Open Google Calendar to create a new event
gcal-new() {
  local title=$1
  local start_date=$2
  local end_date=$3
  local details=${4:-""}
  local location=${5:-""}
  
  if [[ -z "$title" || -z "$start_date" ]]; then
    echo "Usage: gcal-new <title> <start-date-time> [end-date-time] [details] [location]"
    echo "Example: gcal-new \"Team Meeting\" \"2023-06-15T14:00\" \"2023-06-15T15:00\" \"Discuss project status\" \"Conference Room\""
    return 1
  fi
  
  # If end date is not provided, set it to 1 hour after start date
  if [[ -z "$end_date" ]]; then
    # Parse the start date to determine format
    if [[ "$start_date" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
      # Start date is just a date (YYYY-MM-DD), assume all-day event
      end_date="$start_date"
    else
      # Start date includes time, set end date to 1 hour later
      if command -v date >/dev/null 2>&1; then
        end_date=$(date -d "$start_date 1 hour" "+%Y-%m-%dT%H:%M")
      else
        # Simple approximation if date command not available
        end_date="${start_date%:*}:00"
        hour="${end_date##*T}"
        hour="${hour%%:*}"
        new_hour=$((hour + 1))
        end_date="${end_date/T$hour/T$new_hour}"
      fi
    fi
  fi
  
  # URL encode the parameters
  if command -v python3 >/dev/null 2>&1; then
    title=$(python3 -c "import urllib.parse; print(urllib.parse.quote('''$title'''))")
    details=$(python3 -c "import urllib.parse; print(urllib.parse.quote('''$details'''))")
    location=$(python3 -c "import urllib.parse; print(urllib.parse.quote('''$location'''))")
  fi
  
  # Create the Google Calendar URL
  local gcal_url="https://calendar.google.com/calendar/r/eventedit?text=${title}&dates=${start_date}/${end_date}&details=${details}&location=${location}"
  
  # Open the URL
  if [[ "$OSTYPE" == "darwin"* ]]; then
    open "$gcal_url"
  else
    xdg-open "$gcal_url" &> /dev/null
  fi
  
  echo "Opening Google Calendar to create event: $title"
}

# Open Google Calendar with specific view
gcal-open() {
  local view=${1:-"week"}
  local date=${2:-""}
  
  # Validate the view parameter
  case "$view" in
    day|week|month|agenda|year)
      # Valid view
      ;;
    *)
      echo "Invalid view: $view"
      echo "Available views: day, week, month, agenda, year"
      return 1
      ;;
  esac
  
  # Build the URL
  local gcal_url="https://calendar.google.com/calendar/r/$view"
  
  # Add date if provided
  if [[ -n "$date" ]]; then
    # Validate date format (YYYY/MM/DD)
    if [[ ! "$date" =~ ^[0-9]{4}/[0-9]{2}/[0-9]{2}$ ]]; then
      echo "Invalid date format. Use YYYY/MM/DD format."
      return 1
    fi
    
    gcal_url="$gcal_url/$date"
  fi
  
  # Open the URL
  if [[ "$OSTYPE" == "darwin"* ]]; then
    open "$gcal_url"
  else
    xdg-open "$gcal_url" &> /dev/null
  fi
  
  echo "Opening Google Calendar in $view view"
}

# Open Google Calendar for a specific date range
gcal-range() {
  local start_date=$1
  local end_date=$2
  
  if [[ -z "$start_date" || -z "$end_date" ]]; then
    echo "Usage: gcal-range <start-date> <end-date>"
    echo "Example: gcal-range 2023/06/01 2023/06/30"
    echo "Note: Dates should be in format YYYY/MM/DD"
    return 1
  fi
  
  # Validate date formats
  if [[ ! "$start_date" =~ ^[0-9]{4}/[0-9]{2}/[0-9]{2}$ || ! "$end_date" =~ ^[0-9]{4}/[0-9]{2}/[0-9]{2}$ ]]; then
    echo "Invalid date format. Use YYYY/MM/DD format."
    return 1
  fi
  
  # Build the URL
  local gcal_url="https://calendar.google.com/calendar/r/customview?start=${start_date}&end=${end_date}"
  
  # Open the URL
  if [[ "$OSTYPE" == "darwin"* ]]; then
    open "$gcal_url"
  else
    xdg-open "$gcal_url" &> /dev/null
  fi
  
  echo "Opening Google Calendar for date range: $start_date to $end_date"
}
{{- end }}

# ==================================
# Office365 Workflows
# ==================================

{{ if (eq .enable_productivity true) -}}
# Open Office365 apps
office365-open() {
  local app=$1
  
  if [[ -z "$app" ]]; then
    echo "Usage: office365-open <app>"
    echo "Available apps: outlook, word, excel, powerpoint, onenote, teams, onedrive"
    return 1
  fi
  
  local app_url=""
  
  case "$app" in
    outlook)
      app_url="https://outlook.office.com/mail/"
      ;;
    word)
      app_url="https://www.office.com/launch/word"
      ;;
    excel)
      app_url="https://www.office.com/launch/excel"
      ;;
    powerpoint)
      app_url="https://www.office.com/launch/powerpoint"
      ;;
    onenote)
      app_url="https://www.office.com/launch/onenote"
      ;;
    teams)
      app_url="https://teams.microsoft.com/"
      ;;
    onedrive)
      app_url="https://onedrive.live.com/"
      ;;
    *)
      echo "Invalid app: $app"
      echo "Available apps: outlook, word, excel, powerpoint, onenote, teams, onedrive"
      return 1
      ;;
  esac
  
  # Open the URL
  if [[ "$OSTYPE" == "darwin"* ]]; then
    open "$app_url"
  else
    xdg-open "$app_url" &> /dev/null
  fi
  
  echo "Opening Office365 $app"
}

# Create a new document in Office365
office365-new() {
  local doc_type=$1
  
  if [[ -z "$doc_type" ]]; then
    echo "Usage: office365-new <document-type>"
    echo "Available document types: word, excel, powerpoint, onenote"
    return 1
  fi
  
  local doc_url=""
  
  case "$doc_type" in
    word|document)
      doc_url="https://www.office.com/launch/word/new"
      ;;
    excel|spreadsheet)
      doc_url="https://www.office.com/launch/excel/new"
      ;;
    powerpoint|presentation)
      doc_url="https://www.office.com/launch/powerpoint/new"
      ;;
    onenote|notebook)
      doc_url="https://www.office.com/launch/onenote/new"
      ;;
    *)
      echo "Invalid document type: $doc_type"
      echo "Available document types: word, excel, powerpoint, onenote"
      return 1
      ;;
  esac
  
  # Open the URL
  if [[ "$OSTYPE" == "darwin"* ]]; then
    open "$doc_url"
  else
    xdg-open "$doc_url" &> /dev/null
  fi
  
  echo "Creating new Office365 $doc_type document"
}

# Compose a new email in Outlook
outlook-compose() {
  local to=$1
  local subject=$2
  local body=$3
  
  if [[ -z "$to" ]]; then
    echo "Usage: outlook-compose <to> [subject] [body]"
    echo "Example: outlook-compose \"user@example.com\" \"Meeting Tomorrow\" \"Hi, let's meet tomorrow.\""
    return 1
  fi
  
  # URL encode the parameters
  if command -v python3 >/dev/null 2>&1; then
    to=$(python3 -c "import urllib.parse; print(urllib.parse.quote('''$to'''))")
    subject=$(python3 -c "import urllib.parse; print(urllib.parse.quote('''$subject'''))")
    body=$(python3 -c "import urllib.parse; print(urllib.parse.quote('''$body'''))")
  fi
  
  # Create the Outlook URL
  local outlook_url="https://outlook.office.com/mail/deeplink/compose?to=${to}&subject=${subject}&body=${body}"
  
  # Open the URL
  if [[ "$OSTYPE" == "darwin"* ]]; then
    open "$outlook_url"
  else
    xdg-open "$outlook_url" &> /dev/null
  fi
  
  echo "Creating email to $to in Outlook"
}

# Open OneDrive folder
onedrive-open() {
  local folder_path=$1
  
  if [[ -z "$folder_path" ]]; then
    # Open OneDrive root
    local onedrive_url="https://onedrive.live.com/"
  else
    # URL encode the folder path
    if command -v python3 >/dev/null 2>&1; then
      folder_path=$(python3 -c "import urllib.parse; print(urllib.parse.quote('''$folder_path'''))")
    fi
    
    # Create the OneDrive folder URL
    # Note: This is an approximation as the actual URL structure depends on folder IDs
    local onedrive_url="https://onedrive.live.com/?id=root&cid=root&qt=sharedby&path=${folder_path}"
  fi
  
  # Open the URL
  if [[ "$OSTYPE" == "darwin"* ]]; then
    open "$onedrive_url"
  else
    xdg-open "$onedrive_url" &> /dev/null
  fi
  
  if [[ -z "$folder_path" ]]; then
    echo "Opening OneDrive root folder"
  else
    echo "Opening OneDrive folder: $folder_path"
  fi
}
{{- end }}