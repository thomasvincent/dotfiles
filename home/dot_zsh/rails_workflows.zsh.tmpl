# Rails Workflows
# Managed by chezmoi - DO NOT EDIT DIRECTLY

# ==================================
# Rails Development Workflows
# ==================================

{{ if or (and (hasKey . "preferences") (hasKey .preferences "enable_rails") .preferences.enable_rails) (and (hasKey . "enable_dev_tools") .enable_dev_tools) -}}
# Initialize a new Rails project with common configurations
rails-init-project() {
  local project_name=$1
  local db_type=${2:-"postgresql"}
  local options=${@:3}
  local directory=${4:-"{{ if and (hasKey . "preferences") (hasKey .preferences "projects_dir") }}{{ .preferences.projects_dir }}{{ else }}$HOME/Projects{{ end }}/$project_name"}

  if [[ -z "$project_name" ]]; then
    echo "Usage: rails-init-project <project-name> [db-type] [options] [directory]"
    echo "Example: rails-init-project my-app postgresql \"--skip-action-mailbox --skip-action-text\" ~/Projects/my-app"
    echo "Available db-types: postgresql, mysql, sqlite3"
    return 1
  fi

  _require_cmd "rails" "gem install rails" || return 1

  mkdir -p "$(dirname "$directory")"

  # Default options if none provided
  if [[ -z "$options" ]]; then
    options="--skip-action-mailbox --skip-action-text --skip-spring --skip-turbolinks"
  fi

  # Create new Rails app
  echo "Creating new Rails application: $project_name"
  echo "Database: $db_type"
  echo "Options: $options"

  rails new "$directory" --database="$db_type" $options

  # Move into the project directory
  cd "$directory" || return 1

  # Add useful gems to Gemfile
  cat >> Gemfile << 'EOF'

# Project specific gems
gem 'dotenv-rails', '~> 2.8', groups: [:development, :test] # Environment variables
gem 'faraday', '~> 2.7'     # HTTP client
gem 'kaminari', '~> 1.2'    # Pagination
gem 'pundit', '~> 2.3'      # Authorization
gem 'pagy', '~> 6.0'        # Alternative pagination
gem 'scenic', '~> 1.7'      # Database views
gem 'sidekiq', '~> 7.1'     # Background jobs

group :development, :test do
  gem 'factory_bot_rails', '~> 6.2'
  gem 'faker', '~> 3.2'
  gem 'rspec-rails', '~> 6.0'
  gem 'pry-byebug', '~> 3.10'
  gem 'rubocop', '~> 1.50', require: false
  gem 'rubocop-rails', '~> 2.19', require: false
  gem 'rubocop-rspec', '~> 2.22', require: false
  gem 'brakeman', '~> 5.4', require: false
end

group :development do
  gem 'annotate', '~> 3.2'
  gem 'bullet', '~> 7.0'
  gem 'letter_opener', '~> 1.8'
  gem 'rack-mini-profiler', '~> 3.1'
end

group :test do
  gem 'shoulda-matchers', '~> 5.3'
  gem 'simplecov', '~> 0.22', require: false
  gem 'webmock', '~> 3.18'
  gem 'database_cleaner-active_record', '~> 2.1'
end
EOF

  # Install gems
  bundle install

  # Setup RSpec if installed
  if bundle list | grep -q 'rspec-rails'; then
    rails generate rspec:install

    # Configure shoulda-matchers
    cat > spec/support/shoulda_matchers.rb << 'EOF'
require 'shoulda/matchers'

RSpec.configure do |config|
  Shoulda::Matchers.configure do |shoulda_config|
    shoulda_config.integrate do |with|
      with.test_framework :rspec
      with.library :rails
    end
  end
end
EOF

    # Update rails_helper.rb to require support files
    if (( IS_MACOS )); then
      sed -i '' '/^# Dir\[Rails\.root\.join/s/^# //' spec/rails_helper.rb
    else
      sed -i '/^# Dir\[Rails\.root\.join/s/^# //' spec/rails_helper.rb
    fi
  fi

  # Create .env files
  touch .env.development .env.test

  # Add .env files to .gitignore
  cat >> .gitignore << 'EOF'

# Ignore .env files
.env*
!.env.example

# Ignore editor files
.idea/
.vscode/
*.sublime-project
*.sublime-workspace

# Ignore coverage reports
coverage/

# Ignore node modules
node_modules/

# Ignore bundler config
.bundle/

# Ignore master key for decrypting credentials
/config/master.key

# Ignore yarn files
yarn-error.log
yarn-debug.log*
.yarn-integrity

# Ignore uploaded files in development
/storage/
/public/uploads/

# Ignore database backups
/db/backups/
EOF

  # Create .env.example
  cat > .env.example << 'EOF'
# Database configuration
DATABASE_URL=postgres://postgres:postgres@localhost:5432/${DATABASE_NAME}

# Redis configuration
REDIS_URL=redis://localhost:6379/1

# Mailer configuration
MAILER_FROM=noreply@example.com
SMTP_ADDRESS=smtp.example.com
SMTP_PORT=587
SMTP_USERNAME=user
SMTP_PASSWORD=password
SMTP_DOMAIN=example.com

# API keys
# API_KEY=your_key_here
EOF

  # Setup RuboCop
  cat > .rubocop.yml << 'EOF'
require:
  - rubocop-rails
  - rubocop-rspec

AllCops:
  NewCops: enable
  TargetRubyVersion: 3.1
  Exclude:
    - 'bin/**/*'
    - 'db/**/*'
    - 'config/**/*'
    - 'node_modules/**/*'
    - 'script/**/*'
    - 'vendor/**/*'
    - 'tmp/**/*'

Style/Documentation:
  Enabled: false

Style/FrozenStringLiteralComment:
  Enabled: false

Metrics/BlockLength:
  Exclude:
    - 'spec/**/*'

Layout/LineLength:
  Max: 120
EOF

  # Create Docker configuration
  cat > Dockerfile << 'EOF'
FROM ruby:3.2-slim

RUN apt-get update -qq && apt-get install -y \
    build-essential \
    libpq-dev \
    nodejs \
    postgresql-client \
    git \
    curl \
    vim \
    libssl-dev \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

COPY Gemfile Gemfile.lock ./
RUN bundle install

COPY . .

EXPOSE 3000

CMD ["rails", "server", "-b", "0.0.0.0"]
EOF

  # Create docker-compose.yml
  cat > docker-compose.yml << EOF
version: '3.8'
services:
  db:
    image: ${db_type}:14
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      POSTGRES_PASSWORD: postgres
      POSTGRES_USER: postgres
      POSTGRES_DB: ${project_name}_development
    ports:
      - "5432:5432"

  redis:
    image: redis:7
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  web:
    build: .
    command: bash -c "rm -f tmp/pids/server.pid && bundle exec rails s -p 3000 -b '0.0.0.0'"
    volumes:
      - .:/app
      - gem_cache:/usr/local/bundle
    ports:
      - "3000:3000"
    depends_on:
      - db
      - redis
    environment:
      - DATABASE_URL=postgres://postgres:postgres@db:5432/${project_name}_development
      - REDIS_URL=redis://redis:6379/1

  sidekiq:
    build: .
    command: bundle exec sidekiq
    volumes:
      - .:/app
      - gem_cache:/usr/local/bundle
    depends_on:
      - db
      - redis
    environment:
      - DATABASE_URL=postgres://postgres:postgres@db:5432/${project_name}_development
      - REDIS_URL=redis://redis:6379/1

volumes:
  postgres_data:
  redis_data:
  gem_cache:
EOF

  # Replace PostgreSQL with MySQL in docker-compose.yml if needed
  if [[ "$db_type" == "mysql" ]]; then
    if (( IS_MACOS )); then
      sed -i '' 's/postgres:14/mysql:8/' docker-compose.yml
      sed -i '' 's/POSTGRES_PASSWORD/MYSQL_ROOT_PASSWORD/' docker-compose.yml
      sed -i '' 's/POSTGRES_USER/MYSQL_USER/' docker-compose.yml
      sed -i '' 's/POSTGRES_DB/MYSQL_DATABASE/' docker-compose.yml
      sed -i '' 's/var\/lib\/postgresql\/data/var\/lib\/mysql/' docker-compose.yml
      sed -i '' 's/postgres:\/\/postgres:postgres@db:5432/mysql2:\/\/postgres:postgres@db:3306/' docker-compose.yml
      sed -i '' 's/5432:5432/3306:3306/' docker-compose.yml
    else
      sed -i 's/postgres:14/mysql:8/' docker-compose.yml
      sed -i 's/POSTGRES_PASSWORD/MYSQL_ROOT_PASSWORD/' docker-compose.yml
      sed -i 's/POSTGRES_USER/MYSQL_USER/' docker-compose.yml
      sed -i 's/POSTGRES_DB/MYSQL_DATABASE/' docker-compose.yml
      sed -i 's/var\/lib\/postgresql\/data/var\/lib\/mysql/' docker-compose.yml
      sed -i 's/postgres:\/\/postgres:postgres@db:5432/mysql2:\/\/postgres:postgres@db:3306/' docker-compose.yml
      sed -i 's/5432:5432/3306:3306/' docker-compose.yml
    fi
  elif [[ "$db_type" == "sqlite3" ]]; then
    # For SQLite, remove the database service and simplify
    if (( IS_MACOS )); then
      sed -i '' '/^  db:/,/^  redis:/d' docker-compose.yml
      sed -i '' 's/      - db//g' docker-compose.yml
      sed -i '' '/DATABASE_URL/d' docker-compose.yml
      sed -i '' 's/  postgres_data://g' docker-compose.yml
    else
      sed -i '/^  db:/,/^  redis:/d' docker-compose.yml
      sed -i 's/      - db//g' docker-compose.yml
      sed -i '/DATABASE_URL/d' docker-compose.yml
      sed -i 's/  postgres_data://g' docker-compose.yml
    fi
  fi

  # Create bin/setup-dev script
  mkdir -p bin
  cat > bin/setup-dev << 'EOF'
#!/usr/bin/env ruby
require 'fileutils'

APP_ROOT = File.expand_path('..', __dir__)

def system!(*args)
  system(*args) || abort("\n== Command #{args} failed ==")
end

FileUtils.chdir APP_ROOT do
  # This script is a way to set up or update your development environment automatically.
  # This script is idempotent, so that you can run it at any time and get an expectable outcome.
  # Add necessary setup steps to this file.

  puts '== Installing dependencies =='
  system! 'gem install bundler --conservative'
  system('bundle check') || system!('bundle install')

  # Install JavaScript dependencies
  system!('bin/yarn') if File.exist?('bin/yarn')

  puts "\n== Copying sample files =="
  FileUtils.cp '.env.example', '.env.development' unless File.exist?('.env.development')
  FileUtils.cp '.env.example', '.env.test' unless File.exist?('.env.test')

  puts "\n== Preparing database =="
  system! 'bin/rails db:create'
  system! 'bin/rails db:migrate'
  system! 'bin/rails db:seed'

  puts "\n== Removing old logs and tempfiles =="
  system! 'bin/rails log:clear tmp:clear'

  puts "\n== Starting application server =="
  system! 'bin/rails server'
end
EOF
  chmod +x bin/setup-dev

  # Add Procfile for Heroku or Foreman
  cat > Procfile << 'EOF'
web: bundle exec rails server -p $PORT
worker: bundle exec sidekiq -C config/sidekiq.yml
EOF

  # Add Procfile.dev for local development
  cat > Procfile.dev << 'EOF'
web: bundle exec rails server -p 3000
worker: bundle exec sidekiq -C config/sidekiq.yml
EOF

  # Initialize Git repository
  git init
  git add .
  git commit -m "Initial Rails application setup"

  echo "Rails project '$project_name' initialized successfully at $directory"
  echo "Next steps:"
  echo "1. cd $directory"
  echo "2. Update .env.development with your configuration"
  echo "3. Run bin/setup-dev to set up your development environment"
  echo "4. Or run docker-compose up to start with Docker"
}

# Generate a Rails model with boilerplate and specs
rails-gen-model() {
  local model_name=$1
  local fields=${2:-""}

  if [[ -z "$model_name" ]]; then
    echo "Usage: rails-gen-model <model-name> [fields]"
    echo "Example: rails-gen-model User \"name:string email:string:uniq age:integer\""
    return 1
  fi

  # Check if this is a Rails project
  if [[ ! -f "config/application.rb" ]]; then
    echo "Error: Not in a Rails project directory."
    echo "Please run this command from the root of your Rails project."
    return 1
  fi

  # Generate the model
  if [[ -n "$fields" ]]; then
    rails generate model "$model_name" $fields
  else
    rails generate model "$model_name"
  fi

  # Check if RSpec is used in this project
  if [[ -d "spec" && -f "spec/rails_helper.rb" ]]; then
    # Add model specs with FactoryBot if available
    if grep -q "factory_bot" Gemfile; then
      # Determine the correct factory file path
      local factory_dir="spec/factories"
      mkdir -p "$factory_dir"

      # Model name in snake_case
      local model_snake=$(echo "$model_name" | tr '[:upper:]' '[:lower:]')

      # Determine if the factory file exists
      local factory_file="$factory_dir/${model_snake}.rb"

      # Only create factory file if it doesn't exist
      if [[ ! -f "$factory_file" ]]; then
        echo "Enhancing factory for $model_name"

        # Create a basic factory
        cat > "$factory_file" << EOF
FactoryBot.define do
  factory :$model_snake do
EOF

        # Add factory attributes based on fields if provided
        if [[ -n "$fields" ]]; then
          FIELD_PARTS=( ${(@s: :)fields} )
          for field in "${FIELD_PARTS[@]}"; do
            # Split field into name and type
            FIELD_INFO=( ${(@s.:.)field} )
            local field_name="${FIELD_INFO[0]}"
            local field_type="${FIELD_INFO[1]}"

            # Skip fields with no type
            if [[ -z "$field_type" ]]; then
              continue
            fi

            # Add appropriate Faker data based on field type and name
            if [[ "$field_type" == "string" ]]; then
              if [[ "$field_name" == *"name"* ]]; then
                echo "    $field_name { Faker::Name.name }" >> "$factory_file"
              elif [[ "$field_name" == *"email"* ]]; then
                echo "    $field_name { Faker::Internet.email }" >> "$factory_file"
              elif [[ "$field_name" == *"phone"* ]]; then
                echo "    $field_name { Faker::PhoneNumber.phone_number }" >> "$factory_file"
              elif [[ "$field_name" == *"address"* ]]; then
                echo "    $field_name { Faker::Address.street_address }" >> "$factory_file"
              elif [[ "$field_name" == *"city"* ]]; then
                echo "    $field_name { Faker::Address.city }" >> "$factory_file"
              elif [[ "$field_name" == *"country"* ]]; then
                echo "    $field_name { Faker::Address.country }" >> "$factory_file"
              elif [[ "$field_name" == *"title"* ]]; then
                echo "    $field_name { Faker::Book.title }" >> "$factory_file"
              elif [[ "$field_name" == *"description"* || "$field_name" == *"content"* ]]; then
                echo "    $field_name { Faker::Lorem.paragraph }" >> "$factory_file"
              else
                echo "    $field_name { \"Sample $field_name\" }" >> "$factory_file"
              fi
            elif [[ "$field_type" == "text" ]]; then
              echo "    $field_name { Faker::Lorem.paragraphs.join(\"\\n\\n\") }" >> "$factory_file"
            elif [[ "$field_type" == "integer" ]]; then
              if [[ "$field_name" == *"age"* ]]; then
                echo "    $field_name { Faker::Number.between(from: 18, to: 65) }" >> "$factory_file"
              elif [[ "$field_name" == *"price"* || "$field_name" == *"cost"* ]]; then
                echo "    $field_name { Faker::Number.between(from: 10, to: 1000) }" >> "$factory_file"
              elif [[ "$field_name" == *"quantity"* || "$field_name" == *"count"* ]]; then
                echo "    $field_name { Faker::Number.between(from: 1, to: 100) }" >> "$factory_file"
              else
                echo "    $field_name { Faker::Number.number(digits: 3) }" >> "$factory_file"
              fi
            elif [[ "$field_type" == "date" || "$field_type" == "datetime" ]]; then
              echo "    $field_name { Faker::Date.between(from: 1.year.ago, to: Date.today) }" >> "$factory_file"
            elif [[ "$field_type" == "boolean" ]]; then
              echo "    $field_name { [true, false].sample }" >> "$factory_file"
            elif [[ "$field_type" == "decimal" || "$field_type" == "float" ]]; then
              echo "    $field_name { Faker::Number.decimal(l_digits: 2, r_digits: 2) }" >> "$factory_file"
            fi
          done
        fi

        # Close the factory
        echo "  end" >> "$factory_file"
        echo "end" >> "$factory_file"
      fi

      # Enhance the model spec
      local model_spec_file="spec/models/${model_snake}_spec.rb"

      if [[ -f "$model_spec_file" ]]; then
        echo "Enhancing model spec for $model_name"

        # Create a basic spec setup
        cat > "$model_spec_file" << EOF
require 'rails_helper'

RSpec.describe $model_name, type: :model do
  describe 'factory' do
    it 'has a valid factory' do
      expect(build(:$model_snake)).to be_valid
    end
  end

EOF

        # Add validation specs if fields were provided
        if [[ -n "$fields" ]]; then
          echo "  describe 'validations' do" >> "$model_spec_file"

          FIELD_PARTS=( ${(@s: :)fields} )
          for field in "${FIELD_PARTS[@]}"; do
            # Split field into name and type
            FIELD_INFO=( ${(@s.:.)field} )
            local field_name="${FIELD_INFO[0]}"

            # Check if field has a presence validation
            if grep -q "validates.*$field_name.*presence" "app/models/${model_snake}.rb" 2>/dev/null; then
              echo "    it { is_expected.to validate_presence_of(:$field_name) }" >> "$model_spec_file"
            fi

            # Check if field has uniqueness constraint
            if [[ "$field" == *":uniq"* || "$field" == *":unique"* ]]; then
              echo "    it { is_expected.to validate_uniqueness_of(:$field_name) }" >> "$model_spec_file"
            fi
          done

          echo "  end" >> "$model_spec_file"
          echo "" >> "$model_spec_file"
        fi

        # Add associations specs if any are found in the model
        if grep -q "belongs_to\|has_many\|has_one" "app/models/${model_snake}.rb" 2>/dev/null; then
          echo "  describe 'associations' do" >> "$model_spec_file"

          # Check for belongs_to associations
          while read -r assoc; do
            local assoc_name=$(echo "$assoc" | sed -E 's/.*belongs_to[[:space:]]+:([[:alnum:]_]+).*/\1/')
            if [[ -n "$assoc_name" ]]; then
              echo "    it { is_expected.to belong_to(:$assoc_name) }" >> "$model_spec_file"
            fi
          done < <(grep "belongs_to" "app/models/${model_snake}.rb" 2>/dev/null)

          # Check for has_many associations
          while read -r assoc; do
            local assoc_name=$(echo "$assoc" | sed -E 's/.*has_many[[:space:]]+:([[:alnum:]_]+).*/\1/')
            if [[ -n "$assoc_name" ]]; then
              echo "    it { is_expected.to have_many(:$assoc_name) }" >> "$model_spec_file"
            fi
          done < <(grep "has_many" "app/models/${model_snake}.rb" 2>/dev/null)

          # Check for has_one associations
          while read -r assoc; do
            local assoc_name=$(echo "$assoc" | sed -E 's/.*has_one[[:space:]]+:([[:alnum:]_]+).*/\1/')
            if [[ -n "$assoc_name" ]]; then
              echo "    it { is_expected.to have_one(:$assoc_name) }" >> "$model_spec_file"
            fi
          done < <(grep "has_one" "app/models/${model_snake}.rb" 2>/dev/null)

          echo "  end" >> "$model_spec_file"
        fi

        # Close the describe block
        echo "end" >> "$model_spec_file"
      fi
    fi
  fi

  echo "Model $model_name generated successfully"
  echo "Don't forget to run migrations: rails db:migrate"
}

# Generate a Rails controller with views and specs
rails-gen-controller() {
  local controller_name=$1
  local actions=${@:2}

  if [[ -z "$controller_name" ]]; then
    echo "Usage: rails-gen-controller <controller-name> [actions]"
    echo "Example: rails-gen-controller Users index show new create edit update destroy"
    return 1
  fi

  # Check if this is a Rails project
  if [[ ! -f "config/application.rb" ]]; then
    echo "Error: Not in a Rails project directory."
    echo "Please run this command from the root of your Rails project."
    return 1
  fi

  # Generate the controller
  rails generate controller "$controller_name" $actions

  # Check if RSpec is used in this project
  if [[ -d "spec" && -f "spec/rails_helper.rb" ]]; then
    # Controller name in snake_case
    local controller_snake=$(echo "$controller_name" | tr '[:upper:]' '[:lower:]')

    # Controller file path
    local controller_spec_file="spec/controllers/${controller_snake}_controller_spec.rb"

    # Only enhance spec if it exists
    if [[ -f "$controller_spec_file" ]]; then
      echo "Enhancing controller spec for $controller_name"

      # Create a controller spec with full CRUD actions
      cat > "$controller_spec_file" << EOF
require 'rails_helper'

RSpec.describe ${controller_name}Controller, type: :controller do
EOF

      # Add specs for each action
      for action in $actions; do
        # Skip helper, js, etc.
        if [[ "$action" =~ ^(_|.*\..*) ]]; then
          continue
        fi

        cat >> "$controller_spec_file" << EOF

  describe "GET #$action" do
    it "returns a successful response" do
      get :$action
      expect(response).to be_successful
    end

    it "renders the $action template" do
      get :$action
      expect(response).to render_template("$action")
    end
  end
EOF
      done

      # Close the describe block
      echo "end" >> "$controller_spec_file"
    fi

    # Also enhance request specs if they exist
    local request_spec_file="spec/requests/${controller_snake}_spec.rb"

    if [[ -f "$request_spec_file" ]]; then
      echo "Enhancing request spec for $controller_name"

      # Create a request spec covering all endpoints
      cat > "$request_spec_file" << EOF
require 'rails_helper'

RSpec.describe "${controller_name}", type: :request do
EOF

      # Add specs for each action
      for action in $actions; do
        # Skip helper, js, etc.
        if [[ "$action" =~ ^(_|.*\..*) ]]; then
          continue
        fi

        # Determine HTTP verb based on action name
        local verb="get"
        local path="/${controller_snake}/$action"

        if [[ "$action" == "create" ]]; then
          verb="post"
          path="/${controller_snake}"
        elif [[ "$action" == "update" ]]; then
          verb="put"
          path="/${controller_snake}/1"
        elif [[ "$action" == "destroy" ]]; then
          verb="delete"
          path="/${controller_snake}/1"
        elif [[ "$action" == "show" || "$action" == "edit" ]]; then
          path="/${controller_snake}/1"
        elif [[ "$action" == "index" ]]; then
          path="/${controller_snake}"
        fi

        cat >> "$request_spec_file" << EOF

  describe "$verb $path" do
    it "returns a successful response" do
      $verb "$path"
      expect(response).to have_http_status(:success)
    end
  end
EOF
      done

      # Close the describe block
      echo "end" >> "$request_spec_file"
    fi
  fi

  echo "Controller $controller_name generated successfully"
}

# Setup a new Rails API project
rails-init-api() {
  local project_name=$1
  local db_type=${2:-"postgresql"}
  local options=${@:3}
  local directory=${4:-"{{ if and (hasKey . "preferences") (hasKey .preferences "projects_dir") }}{{ .preferences.projects_dir }}{{ else }}$HOME/Projects{{ end }}/$project_name"}

  if [[ -z "$project_name" ]]; then
    echo "Usage: rails-init-api <project-name> [db-type] [options] [directory]"
    echo "Example: rails-init-api my-api postgresql \"--skip-action-mailbox --skip-action-text\" ~/Projects/my-api"
    echo "Available db-types: postgresql, mysql, sqlite3"
    return 1
  fi

  _require_cmd "rails" "gem install rails" || return 1

  mkdir -p "$(dirname "$directory")"

  # Default options if none provided
  if [[ -z "$options" ]]; then
    options="--skip-action-mailbox --skip-action-text --skip-sprockets --skip-spring --skip-javascript --skip-hotwire --skip-jbuilder --skip-system-test --skip-test --api"
  else
    # Ensure --api is included
    options="$options --api"
  fi

  # Create new Rails API app
  echo "Creating new Rails API application: $project_name"
  echo "Database: $db_type"
  echo "Options: $options"

  rails new "$directory" --database="$db_type" $options

  # Move into the project directory
  cd "$directory" || return 1

  # Add useful gems to Gemfile
  cat >> Gemfile << 'EOF'

# Project specific gems
gem 'dotenv-rails', '~> 2.8', groups: [:development, :test] # Environment variables
gem 'faraday', '~> 2.7'     # HTTP client
gem 'jsonapi-serializer', '~> 2.2'  # JSON API serialization
gem 'kaminari', '~> 1.2'    # Pagination
gem 'rack-cors', '~> 2.0'   # CORS handling
gem 'jwt', '~> 2.7'         # JWT authentication
gem 'bcrypt', '~> 3.1'      # Password encryption
gem 'sidekiq', '~> 7.1'     # Background jobs
gem 'activerecord-import', '~> 1.4' # Bulk import

group :development, :test do
  gem 'factory_bot_rails', '~> 6.2'
  gem 'faker', '~> 3.2'
  gem 'rspec-rails', '~> 6.0'
  gem 'pry-byebug', '~> 3.10'
  gem 'rubocop', '~> 1.50', require: false
  gem 'rubocop-rails', '~> 2.19', require: false
  gem 'rubocop-rspec', '~> 2.22', require: false
  gem 'brakeman', '~> 5.4', require: false
end

group :development do
  gem 'annotate', '~> 3.2'
  gem 'bullet', '~> 7.0'
  gem 'rack-mini-profiler', '~> 3.1'
end

group :test do
  gem 'shoulda-matchers', '~> 5.3'
  gem 'simplecov', '~> 0.22', require: false
  gem 'webmock', '~> 3.18'
  gem 'database_cleaner-active_record', '~> 2.1'
end
EOF

  # Install gems
  bundle install

  # Setup RSpec if installed
  if bundle list | grep -q 'rspec-rails'; then
    rails generate rspec:install

    # Configure shoulda-matchers
    mkdir -p spec/support
    cat > spec/support/shoulda_matchers.rb << 'EOF'
require 'shoulda/matchers'

RSpec.configure do |config|
  Shoulda::Matchers.configure do |shoulda_config|
    shoulda_config.integrate do |with|
      with.test_framework :rspec
      with.library :rails
    end
  end
end
EOF

    # Update rails_helper.rb to require support files
    if (( IS_MACOS )); then
      sed -i '' '/^# Dir\[Rails\.root\.join/s/^# //' spec/rails_helper.rb
    else
      sed -i '/^# Dir\[Rails\.root\.join/s/^# //' spec/rails_helper.rb
    fi

    # Add FactoryBot configuration
    cat > spec/support/factory_bot.rb << 'EOF'
RSpec.configure do |config|
  config.include FactoryBot::Syntax::Methods
end
EOF
  fi

  # Configure CORS
  cat > config/initializers/cors.rb << 'EOF'
# Be sure to restart your server when you modify this file.

# Avoid CORS issues when API is called from the frontend app.
# Handle Cross-Origin Resource Sharing (CORS) in order to accept cross-origin AJAX requests.

Rails.application.config.middleware.insert_before 0, Rack::Cors do
  allow do
    origins ENV.fetch('CORS_ALLOWED_ORIGINS', '*').split(',').map(&:strip)

    resource '*',
      headers: :any,
      methods: [:get, :post, :put, :patch, :delete, :options, :head],
      credentials: false,
      max_age: 86400
  end
end
EOF

  # Create JWT authentication concern
  mkdir -p app/controllers/concerns
  cat > app/controllers/concerns/jwt_authenticatable.rb << 'EOF'
module JwtAuthenticatable
  extend ActiveSupport::Concern

  included do
    before_action :authenticate_request

    attr_reader :current_user
  end

  private

  def authenticate_request
    @current_user = AuthorizeApiRequest.call(request.headers).result
    render json: { error: 'Not Authorized' }, status: 401 unless @current_user
  end
end
EOF

  # Create JWT service directory
  mkdir -p app/services/auth

  # Create JWT authentication service
  cat > app/services/auth/authorize_api_request.rb << 'EOF'
class Auth::AuthorizeApiRequest
  def self.call(headers = {})
    new(headers).call
  end

  def initialize(headers = {})
    @headers = headers
  end

  def call
    {
      result: user
    }
  end

  private

  attr_reader :headers

  def user
    @user ||= User.find(decoded_auth_token[:user_id]) if decoded_auth_token
  rescue ActiveRecord::RecordNotFound
    nil
  end

  def decoded_auth_token
    @decoded_auth_token ||= JsonWebToken.decode(http_auth_header)
  end

  def http_auth_header
    if headers['Authorization'].present?
      return headers['Authorization'].split(' ').last
    end
    nil
  end
end
EOF

  # Create JWT token service
  cat > app/services/auth/json_web_token.rb << 'EOF'
class Auth::JsonWebToken
  SECRET_KEY = Rails.application.credentials.secret_key_base

  def self.encode(payload, exp = 24.hours.from_now)
    payload[:exp] = exp.to_i
    JWT.encode(payload, SECRET_KEY)
  end

  def self.decode(token)
    decoded = JWT.decode(token, SECRET_KEY)[0]
    HashWithIndifferentAccess.new decoded
  rescue JWT::DecodeError, JWT::ExpiredSignature
    nil
  end
end
EOF

  # Create API versioning module
  mkdir -p app/controllers/api
  mkdir -p app/controllers/api/v1

  # Create base API controller
  cat > app/controllers/api/base_controller.rb << 'EOF'
module Api
  class BaseController < ApplicationController
    # Common API concerns and methods

    rescue_from ActiveRecord::RecordNotFound, with: :not_found
    rescue_from ActionController::ParameterMissing, with: :bad_request
    rescue_from ActiveRecord::RecordInvalid, with: :unprocessable_entity

    private

    def not_found
      render json: { error: 'Record not found' }, status: :not_found
    end

    def bad_request(exception)
      render json: { error: exception.message }, status: :bad_request
    end

    def unprocessable_entity(exception)
      render json: { error: exception.record.errors.full_messages.join(', ') }, status: :unprocessable_entity
    end
  end
end
EOF

  # Create API v1 controller
  cat > app/controllers/api/v1/base_controller.rb << 'EOF'
module Api
  module V1
    class BaseController < Api::BaseController
      # API v1 specific functionality
    end
  end
end
EOF

  # Create a sample API resource
  cat > app/controllers/api/v1/health_controller.rb << 'EOF'
module Api
  module V1
    class HealthController < BaseController
      skip_before_action :authenticate_request, only: [:index]

      def index
        render json: { status: 'ok', version: '1.0.0' }
      end
    end
  end
end
EOF

  # Update routes.rb
  cat > config/routes.rb << 'EOF'
Rails.application.routes.draw do
  # API routes
  namespace :api do
    namespace :v1 do
      get 'health', to: 'health#index'

      # Add your API endpoints here
    end
  end
end
EOF

  # Create .env files
  touch .env.development .env.test

  # Add .env files to .gitignore
  cat >> .gitignore << 'EOF'

# Ignore .env files
.env*
!.env.example

# Ignore editor files
.idea/
.vscode/
*.sublime-project
*.sublime-workspace

# Ignore coverage reports
coverage/

# Ignore node modules
node_modules/

# Ignore bundler config
.bundle/

# Ignore master key for decrypting credentials
/config/master.key

# Ignore uploaded files in development
/storage/
/public/uploads/

# Ignore database backups
/db/backups/
EOF

  # Create .env.example
  cat > .env.example << 'EOF'
# Database configuration
DATABASE_URL=postgres://postgres:postgres@localhost:5432/${DATABASE_NAME}

# Redis configuration (for Sidekiq)
REDIS_URL=redis://localhost:6379/1

# API configuration
CORS_ALLOWED_ORIGINS=http://localhost:3000,http://localhost:5173

# JWT configuration
JWT_SECRET_KEY=your_secret_key_here
JWT_EXPIRATION_HOURS=24

# Rate limiting
RATE_LIMIT_MAX_REQUESTS=100
RATE_LIMIT_PERIOD_SECONDS=60
EOF

  # Setup RuboCop
  cat > .rubocop.yml << 'EOF'
require:
  - rubocop-rails
  - rubocop-rspec

AllCops:
  NewCops: enable
  TargetRubyVersion: 3.1
  Exclude:
    - 'bin/**/*'
    - 'db/**/*'
    - 'config/**/*'
    - 'node_modules/**/*'
    - 'script/**/*'
    - 'vendor/**/*'
    - 'tmp/**/*'

Style/Documentation:
  Enabled: false

Style/FrozenStringLiteralComment:
  Enabled: false

Metrics/BlockLength:
  Exclude:
    - 'spec/**/*'

Layout/LineLength:
  Max: 120
EOF

  # Create Docker configuration
  cat > Dockerfile << 'EOF'
FROM ruby:3.2-slim

RUN apt-get update -qq && apt-get install -y \
    build-essential \
    libpq-dev \
    postgresql-client \
    git \
    curl \
    vim \
    libssl-dev \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

COPY Gemfile Gemfile.lock ./
RUN bundle install

COPY . .

EXPOSE 3000

CMD ["rails", "server", "-b", "0.0.0.0"]
EOF

  # Create docker-compose.yml
  cat > docker-compose.yml << EOF
version: '3.8'
services:
  db:
    image: ${db_type}:14
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      POSTGRES_PASSWORD: postgres
      POSTGRES_USER: postgres
      POSTGRES_DB: ${project_name}_development
    ports:
      - "5432:5432"

  redis:
    image: redis:7
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  api:
    build: .
    command: bash -c "rm -f tmp/pids/server.pid && bundle exec rails s -p 3000 -b '0.0.0.0'"
    volumes:
      - .:/app
      - gem_cache:/usr/local/bundle
    ports:
      - "3000:3000"
    depends_on:
      - db
      - redis
    environment:
      - DATABASE_URL=postgres://postgres:postgres@db:5432/${project_name}_development
      - REDIS_URL=redis://redis:6379/1
      - CORS_ALLOWED_ORIGINS=*

  sidekiq:
    build: .
    command: bundle exec sidekiq
    volumes:
      - .:/app
      - gem_cache:/usr/local/bundle
    depends_on:
      - db
      - redis
    environment:
      - DATABASE_URL=postgres://postgres:postgres@db:5432/${project_name}_development
      - REDIS_URL=redis://redis:6379/1

volumes:
  postgres_data:
  redis_data:
  gem_cache:
EOF

  # Replace PostgreSQL with MySQL in docker-compose.yml if needed
  if [[ "$db_type" == "mysql" ]]; then
    if (( IS_MACOS )); then
      sed -i '' 's/postgres:14/mysql:8/' docker-compose.yml
      sed -i '' 's/POSTGRES_PASSWORD/MYSQL_ROOT_PASSWORD/' docker-compose.yml
      sed -i '' 's/POSTGRES_USER/MYSQL_USER/' docker-compose.yml
      sed -i '' 's/POSTGRES_DB/MYSQL_DATABASE/' docker-compose.yml
      sed -i '' 's/var\/lib\/postgresql\/data/var\/lib\/mysql/' docker-compose.yml
      sed -i '' 's/postgres:\/\/postgres:postgres@db:5432/mysql2:\/\/postgres:postgres@db:3306/' docker-compose.yml
      sed -i '' 's/5432:5432/3306:3306/' docker-compose.yml
    else
      sed -i 's/postgres:14/mysql:8/' docker-compose.yml
      sed -i 's/POSTGRES_PASSWORD/MYSQL_ROOT_PASSWORD/' docker-compose.yml
      sed -i 's/POSTGRES_USER/MYSQL_USER/' docker-compose.yml
      sed -i 's/POSTGRES_DB/MYSQL_DATABASE/' docker-compose.yml
      sed -i 's/var\/lib\/postgresql\/data/var\/lib\/mysql/' docker-compose.yml
      sed -i 's/postgres:\/\/postgres:postgres@db:5432/mysql2:\/\/postgres:postgres@db:3306/' docker-compose.yml
      sed -i 's/5432:5432/3306:3306/' docker-compose.yml
    fi
  elif [[ "$db_type" == "sqlite3" ]]; then
    # For SQLite, remove the database service and simplify
    if (( IS_MACOS )); then
      sed -i '' '/^  db:/,/^  redis:/d' docker-compose.yml
      sed -i '' 's/      - db//g' docker-compose.yml
      sed -i '' '/DATABASE_URL/d' docker-compose.yml
      sed -i '' 's/  postgres_data://g' docker-compose.yml
    else
      sed -i '/^  db:/,/^  redis:/d' docker-compose.yml
      sed -i 's/      - db//g' docker-compose.yml
      sed -i '/DATABASE_URL/d' docker-compose.yml
      sed -i 's/  postgres_data://g' docker-compose.yml
    fi
  fi

  # Create bin/setup-dev script
  mkdir -p bin
  cat > bin/setup-dev << 'EOF'
#!/usr/bin/env ruby
require 'fileutils'

APP_ROOT = File.expand_path('..', __dir__)

def system!(*args)
  system(*args) || abort("\n== Command #{args} failed ==")
end

FileUtils.chdir APP_ROOT do
  # This script is a way to set up or update your development environment automatically.
  # This script is idempotent, so that you can run it at any time and get an expectable outcome.
  # Add necessary setup steps to this file.

  puts '== Installing dependencies =='
  system! 'gem install bundler --conservative'
  system('bundle check') || system!('bundle install')

  puts "\n== Copying sample files =="
  FileUtils.cp '.env.example', '.env.development' unless File.exist?('.env.development')
  FileUtils.cp '.env.example', '.env.test' unless File.exist?('.env.test')

  puts "\n== Preparing database =="
  system! 'bin/rails db:create'
  system! 'bin/rails db:migrate'
  system! 'bin/rails db:seed'

  puts "\n== Removing old logs and tempfiles =="
  system! 'bin/rails log:clear tmp:clear'

  puts "\n== Starting application server =="
  system! 'bin/rails server'
end
EOF
  chmod +x bin/setup-dev

  # Add Procfile for Heroku or Foreman
  cat > Procfile << 'EOF'
web: bundle exec rails server -p $PORT
worker: bundle exec sidekiq -C config/sidekiq.yml
EOF

  # Add Procfile.dev for local development
  cat > Procfile.dev << 'EOF'
api: bundle exec rails server -p 3000
worker: bundle exec sidekiq -C config/sidekiq.yml
EOF

  # Initialize Git repository
  git init
  git add .
  git commit -m "Initial Rails API application setup"

  echo "Rails API project '$project_name' initialized successfully at $directory"
  echo "Next steps:"
  echo "1. cd $directory"
  echo "2. Update .env.development with your configuration"
  echo "3. Run bin/setup-dev to set up your development environment"
  echo "4. Or run docker-compose up to start with Docker"
  echo "5. Visit http://localhost:3000/api/v1/health to verify the API is running"
}

# Generate a Rails API resource with CRUD endpoints
rails-gen-api-resource() {
  local resource_name=$1
  local fields=${2:-""}

  if [[ -z "$resource_name" ]]; then
    echo "Usage: rails-gen-api-resource <resource-name> [fields]"
    echo "Example: rails-gen-api-resource post \"title:string content:text published:boolean\""
    return 1
  fi

  # Check if this is a Rails project
  if [[ ! -f "config/application.rb" ]]; then
    echo "Error: Not in a Rails project directory."
    echo "Please run this command from the root of your Rails project."
    return 1
  fi

  # Convert resource name to singular form
  local resource_singular
  resource_singular=$(echo "$resource_name" | ruby -e "require 'active_support/all'; puts STDIN.read.strip.singularize") || return 1

  # Generate the model
  rails generate model "$resource_singular" $fields

  # Generate the API controller
  local controller_name="api/v1/${resource_name}"
  rails generate controller "$controller_name" index show create update destroy --skip-template-engine --skip-helper --skip-assets

  # Modify the API controller
  local controller_file="app/controllers/api/v1/${resource_name}_controller.rb"

  if [[ -f "$controller_file" ]]; then
    # Get the model class name in proper case
    local model_class
    model_class=$(echo "$resource_singular" | ruby -e "require 'active_support/all'; puts STDIN.read.strip.camelize") || return 1

    # Create or override the controller file
    cat > "$controller_file" << EOF
module Api
  module V1
    class ${(C)resource_name}Controller < BaseController
      before_action :set_${resource_singular}, only: [:show, :update, :destroy]

      # GET /api/v1/${resource_name}
      def index
        @${resource_name} = ${model_class}.all

        # Add pagination if available
        @${resource_name} = @${resource_name}.page(params[:page]).per(params[:per_page]) if defined?(Kaminari)

        render json: @${resource_name}
      end

      # GET /api/v1/${resource_name}/1
      def show
        render json: @${resource_singular}
      end

      # POST /api/v1/${resource_name}
      def create
        @${resource_singular} = ${model_class}.new(${resource_singular}_params)

        if @${resource_singular}.save
          render json: @${resource_singular}, status: :created
        else
          render json: { errors: @${resource_singular}.errors.full_messages }, status: :unprocessable_entity
        end
      end

      # PATCH/PUT /api/v1/${resource_name}/1
      def update
        if @${resource_singular}.update(${resource_singular}_params)
          render json: @${resource_singular}
        else
          render json: { errors: @${resource_singular}.errors.full_messages }, status: :unprocessable_entity
        end
      end

      # DELETE /api/v1/${resource_name}/1
      def destroy
        @${resource_singular}.destroy
        head :no_content
      end

      private

      def set_${resource_singular}
        @${resource_singular} = ${model_class}.find(params[:id])
      end

      def ${resource_singular}_params
        params.require(:${resource_singular}).permit(${permitted_params})
      end
    end
  end
end
EOF

    # Generate permitted parameters based on fields
    if [[ -n "$fields" ]]; then
      local permitted_params=""

      FIELD_PARTS=( ${(@s: :)fields} )
      for field in "${FIELD_PARTS[@]}"; do
        # Split field into name and type
        FIELD_INFO=( ${(@s.:.)field} )
        local field_name="${FIELD_INFO[0]}"

        # Append field to permitted params
        if [[ -n "$permitted_params" ]]; then
          permitted_params="$permitted_params, :$field_name"
        else
          permitted_params=":$field_name"
        fi
      done

      # Replace the placeholder with the actual permitted params
      if (( IS_MACOS )); then
        sed -i '' "s/\${permitted_params}/$permitted_params/" "$controller_file"
      else
        sed -i "s/\${permitted_params}/$permitted_params/" "$controller_file"
      fi
    else
      # If no fields provided, use a generic placeholder
      if (( IS_MACOS )); then
        sed -i '' "s/\${permitted_params}/*/" "$controller_file"
      else
        sed -i "s/\${permitted_params}/*/" "$controller_file"
      fi
    fi
  fi

  # Update routes
  local routes_file="config/routes.rb"

  if grep -q "namespace :api" "$routes_file"; then
    if grep -q "namespace :v1" "$routes_file"; then
      # Add the resource to the v1 namespace
      if grep -q "end # end v1" "$routes_file"; then
        # Add before the v1 namespace end comment
        if (( IS_MACOS )); then
          sed -i '' "/end # end v1/i\\
      resources :${resource_name}\\
" "$routes_file"
        else
          sed -i "/end # end v1/i\\      resources :${resource_name}" "$routes_file"
        fi
      elif grep -q "end # v1" "$routes_file"; then
        # Add before the v1 namespace end comment
        if (( IS_MACOS )); then
          sed -i '' "/end # v1/i\\
      resources :${resource_name}\\
" "$routes_file"
        else
          sed -i "/end # v1/i\\      resources :${resource_name}" "$routes_file"
        fi
      else
        # Add before the first end after namespace :v1
        ruby -i -pe 'gsub(/namespace :v1 do\n([^\n]*\n)*(  end)/, "namespace :v1 do\n\\1    resources :'"${resource_name}"'\n\\2")' "$routes_file"
      fi
    else
      # Add the v1 namespace with the resource
      if (( IS_MACOS )); then
        sed -i '' "/namespace :api do/a\\
    namespace :v1 do\\
      resources :${resource_name}\\
    end # end v1\\
" "$routes_file"
      else
        sed -i "/namespace :api do/a\\    namespace :v1 do\\n      resources :${resource_name}\\n    end # end v1" "$routes_file"
      fi
    fi
  else
    # Add the entire API namespace structure
    if (( IS_MACOS )); then
      sed -i '' "/Rails.application.routes.draw do/a\\
  # API routes\\
  namespace :api do\\
    namespace :v1 do\\
      resources :${resource_name}\\
    end # end v1\\
  end # end api\\
" "$routes_file"
    else
      sed -i "/Rails.application.routes.draw do/a\\  # API routes\\n  namespace :api do\\n    namespace :v1 do\\n      resources :${resource_name}\\n    end # end v1\\n  end # end api" "$routes_file"
    fi
  fi

  # Generate serializer if jsonapi-serializer gem is available
  if bundle list | grep -q 'jsonapi-serializer'; then
    mkdir -p app/serializers

    local serializer_file="app/serializers/${resource_singular}_serializer.rb"

    cat > "$serializer_file" << EOF
class ${model_class}Serializer
  include JSONAPI::Serializer

  # Define attributes to include
EOF

    # Add attributes based on fields
    if [[ -n "$fields" ]]; then
      FIELD_PARTS=( ${(@s: :)fields} )
      for field in "${FIELD_PARTS[@]}"; do
        # Split field into name and type
        FIELD_INFO=( ${(@s.:.)field} )
        local field_name="${FIELD_INFO[0]}"

        # Add attribute to serializer
        echo "  attribute :$field_name" >> "$serializer_file"
      done
    else
      # Add a note about adding attributes
      echo "  # Add attributes here, e.g.:" >> "$serializer_file"
      echo "  # attribute :title" >> "$serializer_file"
      echo "  # attribute :content" >> "$serializer_file"
    fi

    # Close the serializer class
    echo "end" >> "$serializer_file"

    # Update the controller to use the serializer
    if (( IS_MACOS )); then
      sed -i '' "s/render json: @${resource_name}/render json: ${model_class}Serializer.new(@${resource_name}).serializable_hash/" "$controller_file"
      sed -i '' "s/render json: @${resource_singular}, status: :created/render json: ${model_class}Serializer.new(@${resource_singular}).serializable_hash, status: :created/" "$controller_file"
      sed -i '' "s/render json: @${resource_singular}$/render json: ${model_class}Serializer.new(@${resource_singular}).serializable_hash/" "$controller_file"
    else
      sed -i "s/render json: @${resource_name}/render json: ${model_class}Serializer.new(@${resource_name}).serializable_hash/" "$controller_file"
      sed -i "s/render json: @${resource_singular}, status: :created/render json: ${model_class}Serializer.new(@${resource_singular}).serializable_hash, status: :created/" "$controller_file"
      sed -i "s/render json: @${resource_singular}$/render json: ${model_class}Serializer.new(@${resource_singular}).serializable_hash/" "$controller_file"
    fi
  fi

  # Check if RSpec is used in this project
  if [[ -d "spec" && -f "spec/rails_helper.rb" ]]; then
    # Add request specs for the API
    mkdir -p spec/requests/api/v1

    local request_spec_file="spec/requests/api/v1/${resource_name}_spec.rb"

    cat > "$request_spec_file" << EOF
require 'rails_helper'

RSpec.describe "Api::V1::${(C)resource_name}", type: :request do
  let(:valid_headers) do
    {}
  end

  describe "GET /api/v1/${resource_name}" do
    it "returns a success response" do
      create(:${resource_singular}) # assuming FactoryBot is set up
      get api_v1_${resource_name}_path, headers: valid_headers
      expect(response).to be_successful
    end
  end

  describe "GET /api/v1/${resource_name}/:id" do
    it "returns a success response" do
      ${resource_singular} = create(:${resource_singular})
      get api_v1_${resource_singular}_path(${resource_singular}), headers: valid_headers
      expect(response).to be_successful
    end
  end

  describe "POST /api/v1/${resource_name}" do
    context "with valid parameters" do
      let(:valid_attributes) do
        attributes_for(:${resource_singular})
      end

      it "creates a new ${model_class}" do
        expect {
          post api_v1_${resource_name}_path,
               params: { ${resource_singular}: valid_attributes },
               headers: valid_headers
        }.to change(${model_class}, :count).by(1)
      end

      it "returns a created status" do
        post api_v1_${resource_name}_path,
             params: { ${resource_singular}: valid_attributes },
             headers: valid_headers
        expect(response).to have_http_status(:created)
      end
    end

    context "with invalid parameters" do
      let(:invalid_attributes) do
        # Add attributes that would fail validation
        { name: '' }
      end

      it "does not create a new ${model_class}" do
        expect {
          post api_v1_${resource_name}_path,
               params: { ${resource_singular}: invalid_attributes },
               headers: valid_headers
        }.to change(${model_class}, :count).by(0)
      end

      it "returns an unprocessable entity status" do
        post api_v1_${resource_name}_path,
             params: { ${resource_singular}: invalid_attributes },
             headers: valid_headers
        expect(response).to have_http_status(:unprocessable_entity)
      end
    end
  end

  describe "PUT /api/v1/${resource_name}/:id" do
    context "with valid parameters" do
      let(:new_attributes) do
        # Add attributes to update
        { name: 'Updated Name' }
      end

      it "updates the requested ${resource_singular}" do
        ${resource_singular} = create(:${resource_singular})
        put api_v1_${resource_singular}_path(${resource_singular}),
            params: { ${resource_singular}: new_attributes },
            headers: valid_headers
        ${resource_singular}.reload
        # Add assertions for the updated fields
        # expect(${resource_singular}.name).to eq('Updated Name')
      end

      it "returns a success response" do
        ${resource_singular} = create(:${resource_singular})
        put api_v1_${resource_singular}_path(${resource_singular}),
            params: { ${resource_singular}: new_attributes },
            headers: valid_headers
        expect(response).to be_successful
      end
    end
  end

  describe "DELETE /api/v1/${resource_name}/:id" do
    it "destroys the requested ${resource_singular}" do
      ${resource_singular} = create(:${resource_singular})
      expect {
        delete api_v1_${resource_singular}_path(${resource_singular}), headers: valid_headers
      }.to change(${model_class}, :count).by(-1)
    end

    it "returns no content status" do
      ${resource_singular} = create(:${resource_singular})
      delete api_v1_${resource_singular}_path(${resource_singular}), headers: valid_headers
      expect(response).to have_http_status(:no_content)
    end
  end
end
EOF
  fi

  echo "API Resource ${resource_name} generated successfully"
  echo "Routes added to config/routes.rb"
  echo "Don't forget to run migrations: rails db:migrate"
}

# Generate a Rails service object
rails-gen-service() {
  local service_name=$1
  local method_name=${2:-"call"}

  if [[ -z "$service_name" ]]; then
    echo "Usage: rails-gen-service <service-name> [method-name]"
    echo "Example: rails-gen-service ProcessPayment execute"
    return 1
  fi

  # Check if this is a Rails project
  if [[ ! -f "config/application.rb" ]]; then
    echo "Error: Not in a Rails project directory."
    echo "Please run this command from the root of your Rails project."
    return 1
  fi

  mkdir -p app/services

  # Convert service name to proper class name
  local service_class
  service_class=$(echo "$service_name" | ruby -e "require 'active_support/all'; puts STDIN.read.strip.camelize") || return 1

  # Create the service file
  local service_file="app/services/${service_name.rb}"

  cat > "app/services/${service_name}.rb" << EOF
class ${service_class}
  def self.${method_name}(*args)
    new(*args).${method_name}
  end

  def initialize(options = {})
    # Initialize with arguments or options
    @options = options
  end

  def ${method_name}
    # Main service method
    # Add your business logic here

    # Example:
    # return success_response(result) if valid?
    # failure_response("Error message")
  end

  private

  def success_response(data = nil)
    { success: true, data: data }
  end

  def failure_response(error = nil)
    { success: false, error: error }
  end

  def valid?
    # Add validation logic here
    true
  end
end
EOF

  # Check if RSpec is used in this project
  if [[ -d "spec" && -f "spec/rails_helper.rb" ]]; then
    # Create service spec
    mkdir -p spec/services

    local spec_file="spec/services/${service_name}_spec.rb"

    cat > "$spec_file" << EOF
require 'rails_helper'

RSpec.describe ${service_class} do
  describe ".${method_name}" do
    it "calls instance method ${method_name}" do
      options = { key: 'value' }
      instance = instance_double(${service_class})

      expect(${service_class}).to receive(:new).with(options).and_return(instance)
      expect(instance).to receive(:${method_name})

      ${service_class}.${method_name}(options)
    end
  end

  describe "#${method_name}" do
    subject { ${service_class}.new(options) }
    let(:options) { {} }

    it "returns a success response when valid" do
      allow(subject).to receive(:valid?).and_return(true)

      result = subject.${method_name}

      expect(result).to include(success: true)
    end

    it "returns a failure response when invalid" do
      allow(subject).to receive(:valid?).and_return(false)

      result = subject.${method_name}

      expect(result).to include(success: false)
    end
  end
end
EOF
  fi

  echo "Service ${service_class} generated successfully at app/services/${service_name}.rb"
  if [[ -f "$spec_file" ]]; then
    echo "Spec file created at $spec_file"
  fi
}

# Run a Rails database migration
rails-db-migrate() {
  local env=${1:-"development"}

  # Check if this is a Rails project
  if [[ ! -f "config/application.rb" ]]; then
    echo "Error: Not in a Rails project directory."
    echo "Please run this command from the root of your Rails project."
    return 1
  fi

  echo "Running migrations in $env environment..."

  if [[ "$env" == "production" ]]; then
    read "confirm?Are you sure you want to run migrations in production? (y/n) "
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
      echo "Migration cancelled."
      return 1
    fi
  fi

  RAILS_ENV=$env rails db:migrate

  # Show the schema version
  echo "Current schema version:"
  RAILS_ENV=$env rails db:version
}

# Rails database operations
rails-db() {
  local operation=$1
  local env=${2:-"development"}

  # Check if this is a Rails project
  if [[ ! -f "config/application.rb" ]]; then
    echo "Error: Not in a Rails project directory."
    echo "Please run this command from the root of your Rails project."
    return 1
  fi

  case "$operation" in
    migrate)
      echo "Running migrations in $env environment..."
      RAILS_ENV=$env rails db:migrate
      ;;
    rollback)
      echo "Rolling back last migration in $env environment..."
      RAILS_ENV=$env rails db:rollback
      ;;
    reset)
      if [[ "$env" == "production" ]]; then
        echo "Error: Refusing to reset the production database."
        echo "If you really want to do this, use rails directly."
        return 1
      fi

      echo "Resetting $env database (all data will be lost)..."
      read "confirm?Are you sure? (y/n) "
      if [[ "$confirm" =~ ^[Yy]$ ]]; then
        RAILS_ENV=$env rails db:drop db:create db:migrate db:seed
      else
        echo "Database reset cancelled."
      fi
      ;;
    create)
      echo "Creating $env database..."
      RAILS_ENV=$env rails db:create
      ;;
    drop)
      if [[ "$env" == "production" ]]; then
        echo "Error: Refusing to drop the production database."
        echo "If you really want to do this, use rails directly."
        return 1
      fi

      echo "Dropping $env database (all data will be lost)..."
      read "confirm?Are you sure? (y/n) "
      if [[ "$confirm" =~ ^[Yy]$ ]]; then
        RAILS_ENV=$env rails db:drop
      else
        echo "Database drop cancelled."
      fi
      ;;
    seed)
      echo "Running seeds in $env environment..."
      RAILS_ENV=$env rails db:seed
      ;;
    setup)
      if [[ "$env" == "production" ]]; then
        echo "Error: Refusing to setup the production database."
        echo "If you really want to do this, use rails directly."
        return 1
      fi

      echo "Setting up $env database..."
      RAILS_ENV=$env rails db:setup
      ;;
    version)
      echo "Current schema version for $env:"
      RAILS_ENV=$env rails db:version
      ;;
    backup)
      local timestamp=$(date +"%Y%m%d%H%M%S")
      local backup_dir="db/backups"
      mkdir -p "$backup_dir"
      local backup_file="$backup_dir/${env}_${timestamp}.sql"

      echo "Backing up $env database to $backup_file..."

      # Check if this is a PostgreSQL or MySQL database
      if grep -q "adapter: postgresql" config/database.yml; then
        # PostgreSQL
        RAILS_ENV=$env rails db:backup:dump "$backup_file"
      elif grep -q "adapter: mysql" config/database.yml; then
        # MySQL
        RAILS_ENV=$env rails db:backup:dump "$backup_file"
      else
        echo "Error: Unsupported database adapter."
        echo "Only PostgreSQL and MySQL are supported for backups."
        return 1
      fi

      echo "Backup complete: $backup_file"
      ;;
    restore)
      local backup_file=$3

      if [[ -z "$backup_file" ]]; then
        echo "Error: No backup file specified."
        echo "Usage: rails-db restore <environment> <backup-file>"
        return 1
      fi

      if [[ ! -f "$backup_file" ]]; then
        echo "Error: Backup file not found: $backup_file"
        return 1
      fi

      echo "Restoring $env database from $backup_file..."
      read "confirm?This will overwrite all data in the $env database. Continue? (y/n) "
      if [[ "$confirm" =~ ^[Yy]$ ]]; then
        # Check if this is a PostgreSQL or MySQL database
        if grep -q "adapter: postgresql" config/database.yml; then
          # PostgreSQL
          RAILS_ENV=$env rails db:backup:load "$backup_file"
        elif grep -q "adapter: mysql" config/database.yml; then
          # MySQL
          RAILS_ENV=$env rails db:backup:load "$backup_file"
        else
          echo "Error: Unsupported database adapter."
          echo "Only PostgreSQL and MySQL are supported for restores."
          return 1
        fi

        echo "Restore complete."
      else
        echo "Database restore cancelled."
      fi
      ;;
    *)
      echo "Usage: rails-db <operation> [environment]"
      echo "Available operations:"
      echo "  migrate  - Run pending migrations"
      echo "  rollback - Roll back the last migration"
      echo "  reset    - Drop, create, migrate, and seed the database"
      echo "  create   - Create the database"
      echo "  drop     - Drop the database"
      echo "  seed     - Load the seed data"
      echo "  setup    - Create, migrate, and seed the database"
      echo "  version  - Show current schema version"
      echo "  backup   - Create a database backup"
      echo "  restore  - Restore from a database backup"
      return 1
      ;;
  esac
}
{{- end }}
