# Cloud provider configurations
# Managed by chezmoi - DO NOT EDIT DIRECTLY

{{ if .cloud.aws -}}
# AWS Configuration
export AWS_REGION="${AWS_REGION:-us-west-2}"
export AWS_DEFAULT_REGION="${AWS_DEFAULT_REGION:-$AWS_REGION}"
export AWS_SDK_LOAD_CONFIG=1

# AWS CLI completions
if command -v aws_completer &>/dev/null; then
  complete -C aws_completer aws
fi

# AWS Functions
aws-profile() {
  export AWS_PROFILE="$1"
  echo "AWS Profile set to: $AWS_PROFILE"
}

aws-list-profiles() {
  grep '\[profile' ~/.aws/config | sed -e 's/\[profile \(.*\)\]/\1/'
}

aws-who() {
  aws sts get-caller-identity
}
{{ end -}}

{{ if .cloud.azure -}}
# Azure Configuration
export AZURE_CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/azure"

# Azure Functions
az-login() {
  az login
}

az-account() {
  az account show
}

az-subscriptions() {
  az account list --output table
}

az-set-subscription() {
  az account set --subscription "$1"
  echo "Azure subscription set to: $1"
}
{{ end -}}

{{ if .cloud.gcp -}}
# Google Cloud Configuration
export CLOUDSDK_CONFIG="${XDG_CONFIG_HOME:-$HOME/.config}/gcloud"

# Source Google Cloud SDK completions
if [ -f "{{ if eq .chezmoi.os "darwin" -}}
/opt/homebrew/Caskroom/google-cloud-sdk/latest/google-cloud-sdk
{{- else -}}
/usr/share/google-cloud-sdk
{{- end -}}/completion.zsh.inc" ]; then
  source "{{ if eq .chezmoi.os "darwin" -}}
/opt/homebrew/Caskroom/google-cloud-sdk/latest/google-cloud-sdk
{{- else -}}
/usr/share/google-cloud-sdk
{{- end -}}/completion.zsh.inc"
fi

# GCP Functions
gcp-project() {
  gcloud config set project "$1"
  echo "GCP Project set to: $1"
}

gcp-list-projects() {
  gcloud projects list
}

gcp-who() {
  gcloud auth list
}
{{ end -}}

{{ if .cloud.digitalocean -}}
# DigitalOcean Configuration
export DIGITALOCEAN_CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/doctl"

# Helper function to check for doctl installation
_check_doctl() {
  if ! command -v doctl >/dev/null 2>&1; then
    echo "Error: doctl CLI not installed."
    echo "Install with: brew install doctl (macOS) or snap install doctl (Linux)"
    return 1
  fi

  if ! doctl account get >/dev/null 2>&1; then
    echo "Error: doctl not authenticated."
    echo "Run 'doctl auth init' to authenticate with DigitalOcean."
    return 1
  fi

  return 0
}

# List DigitalOcean droplets with details
do-droplets() {
  _check_doctl || return 1

  echo "Listing DigitalOcean droplets..."
  doctl compute droplet list --format "ID,Name,Public IPv4,Memory,VCPUs,Disk,Region,Status,Tags"
}

# Create a new DigitalOcean droplet
do-create-droplet() {
  local name=$1
  local size=${2:-"s-1vcpu-1gb"}
  local region=${3:-"nyc1"}
  local image=${4:-"ubuntu-22-04-x64"}
  local ssh_key=${5:-""}

  _check_doctl || return 1

  if [[ -z "$name" ]]; then
    echo "Usage: do-create-droplet <name> [size] [region] [image] [ssh-key-id]"
    echo "Default size: s-1vcpu-1gb"
    echo "Default region: nyc1"
    echo "Default image: ubuntu-22-04-x64"
    echo ""
    echo "Available sizes:"
    doctl compute size list --format "Slug,Description,Memory,VCPUs,Disk,PriceMonthly"
    echo ""
    echo "Available regions:"
    doctl compute region list --format "Slug,Name,Available"
    echo ""
    echo "Available images:"
    doctl compute image list --public --format "Slug,Name,Type,Distribution,Status" | grep -E 'ubuntu|debian|centos|fedora'
    echo ""
    echo "Your SSH keys:"
    doctl compute ssh-key list --format "ID,Name,Fingerprint"
    return 1
  fi

  local ssh_key_param=""
  if [[ -n "$ssh_key" ]]; then
    ssh_key_param="--ssh-keys $ssh_key"
  fi

  echo "Creating DigitalOcean droplet $name..."
  doctl compute droplet create "$name" \
    --size "$size" \
    --image "$image" \
    --region "$region" \
    $ssh_key_param \
    --wait

  # Show the new droplet details
  echo "Droplet created:"
  doctl compute droplet get "$name" --format "ID,Name,Public IPv4,Memory,VCPUs,Disk,Region,Status"
}

# Delete a DigitalOcean droplet
do-delete-droplet() {
  local droplet_id=$1

  _check_doctl || return 1

  if [[ -z "$droplet_id" ]]; then
    echo "Usage: do-delete-droplet <droplet-id>"
    echo "Available droplets:"
    doctl compute droplet list --format "ID,Name,Public IPv4,Status"
    return 1
  fi

  echo "Warning: This will permanently delete the droplet with ID $droplet_id."
  read -p "Are you sure you want to continue? (y/N) " confirm

  if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
    echo "Operation canceled."
    return 0
  fi

  echo "Deleting DigitalOcean droplet $droplet_id..."
  doctl compute droplet delete "$droplet_id" --force
}

# Create a LAMP stack droplet with one-click app
do-create-lamp() {
  local name=$1
  local size=${2:-"s-1vcpu-1gb"}
  local region=${3:-"nyc1"}

  _check_doctl || return 1

  if [[ -z "$name" ]]; then
    echo "Usage: do-create-lamp <name> [size] [region]"
    echo "Creates a LAMP stack one-click application droplet"
    return 1
  fi

  echo "Creating LAMP stack droplet $name..."
  doctl compute droplet create "$name" \
    --size "$size" \
    --image "lamp-20-04" \
    --region "$region" \
    --wait

  # Show the new droplet details
  echo "LAMP Stack droplet created:"
  doctl compute droplet get "$name" --format "ID,Name,Public IPv4,Memory,VCPUs,Status"

  ip=$(doctl compute droplet get "$name" --format PublicIPv4 --no-header)
  echo ""
  echo "Your LAMP stack is being set up at: http://$ip"
  echo "It may take a few minutes to complete the installation."
}

# Create a WordPress droplet with one-click app
do-create-wordpress() {
  local name=$1
  local size=${2:-"s-1vcpu-1gb"}
  local region=${3:-"nyc1"}

  _check_doctl || return 1

  if [[ -z "$name" ]]; then
    echo "Usage: do-create-wordpress <name> [size] [region]"
    echo "Creates a WordPress one-click application droplet"
    return 1
  fi

  echo "Creating WordPress droplet $name..."
  doctl compute droplet create "$name" \
    --size "$size" \
    --image "wordpress-20-04" \
    --region "$region" \
    --wait

  # Show the new droplet details
  echo "WordPress droplet created:"
  doctl compute droplet get "$name" --format "ID,Name,Public IPv4,Memory,VCPUs,Status"

  ip=$(doctl compute droplet get "$name" --format PublicIPv4 --no-header)
  echo ""
  echo "Your WordPress site is being set up at: http://$ip"
  echo "It may take a few minutes to complete the installation."
  echo "Follow the on-screen instructions when you visit the site to complete setup."
}

# List DigitalOcean volumes
do-volumes() {
  _check_doctl || return 1

  echo "Listing DigitalOcean volumes..."
  doctl compute volume list --format "ID,Name,Size,Region,Filesystem Type,Droplet IDs"
}

# Create a database cluster
do-create-db() {
  local name=$1
  local engine=${2:-"mysql"}
  local size=${3:-"db-s-1vcpu-1gb"}
  local region=${4:-"nyc1"}
  local version=${5:-"8"}

  _check_doctl || return 1

  if [[ -z "$name" ]]; then
    echo "Usage: do-create-db <name> [engine] [size] [region] [version]"
    echo "Default engine: mysql"
    echo "Default size: db-s-1vcpu-1gb"
    echo "Default region: nyc1"
    echo "Default version: 8 (for MySQL)"
    echo ""
    echo "Available engines: mysql, pg (PostgreSQL), redis, mongodb"
    echo ""
    echo "Available regions:"
    doctl compute region list --format "Slug,Name,Available"
    return 1
  fi

  echo "Creating $engine database cluster $name..."
  doctl databases create "$name" \
    --engine "$engine" \
    --size "$size" \
    --region "$region" \
    --version "$version"

  # Show the new database details
  echo "Database cluster created:"
  doctl databases get "$name"
}

# List Kubernetes clusters
do-k8s() {
  _check_doctl || return 1

  echo "Listing DigitalOcean Kubernetes clusters..."
  doctl kubernetes cluster list
}

# Create a Kubernetes cluster
do-create-k8s() {
  local name=$1
  local region=${2:-"nyc1"}
  local size=${3:-"s-2vcpu-2gb"}
  local count=${4:-"2"}
  local version=${5:-""}

  _check_doctl || return 1

  if [[ -z "$name" ]]; then
    echo "Usage: do-create-k8s <name> [region] [size] [node-count] [version]"
    echo "Default region: nyc1"
    echo "Default size: s-2vcpu-2gb"
    echo "Default node count: 2"
    echo ""
    echo "Available regions:"
    doctl compute region list --format "Slug,Name,Available"
    echo ""
    echo "Available Kubernetes versions:"
    doctl kubernetes options versions
    return 1
  fi

  if [[ -z "$version" ]]; then
    version=$(doctl kubernetes options versions | grep -v "Slug" | head -1 | awk '{print $1}')
  fi

  echo "Creating Kubernetes cluster $name..."
  doctl kubernetes cluster create "$name" \
    --region "$region" \
    --size "$size" \
    --count "$count" \
    --version "$version"

  # Show the new cluster details
  echo "Kubernetes cluster created:"
  doctl kubernetes cluster get "$name"
}

# Configure kubectl to use a DigitalOcean Kubernetes cluster
do-k8s-config() {
  local cluster_id=$1

  _check_doctl || return 1

  if [[ -z "$cluster_id" ]]; then
    echo "Usage: do-k8s-config <cluster-id>"
    echo "Available clusters:"
    doctl kubernetes cluster list --format "ID,Name,Region,Version,Status"
    return 1
  fi

  echo "Configuring kubectl for DigitalOcean Kubernetes cluster $cluster_id..."
  doctl kubernetes cluster kubeconfig save "$cluster_id"

  # Verify the connection
  echo "Testing connection to cluster..."
  kubectl get nodes
}

# Create a new app from current directory
do-app-create() {
  local name=$1
  local region=${2:-"nyc"}

  _check_doctl || return 1

  if [[ -z "$name" ]]; then
    echo "Usage: do-app-create <name> [region]"
    echo "Creates a new App Platform app from the current directory"
    echo "Default region: nyc"
    return 1
  fi

  if [[ ! -f "Dockerfile" && ! -f "docker-compose.yml" && ! -f "package.json" && ! -f "requirements.txt" ]]; then
    echo "Warning: No Dockerfile, docker-compose.yml, package.json, or requirements.txt found in the current directory."
    echo "DigitalOcean App Platform may not be able to detect the application type."
    read -p "Continue? (y/N) " confirm

    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
      echo "Operation canceled."
      return 0
    fi
  fi

  echo "Creating App Platform app $name..."
  doctl apps create --spec <(doctl apps spec create --name "$name" --region "$region")

  echo "App created! To deploy your code, follow the instructions from DigitalOcean."
}

# Legacy functions (for backward compatibility)
do-list-droplets() {
  do-droplets
}

do-list-regions() {
  doctl compute region list
}
{{ end -}}

{{ if .cloud.oracle -}}
# Oracle Cloud Configuration
export OCI_CLI_CONFIG_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/oci/config"
export OCI_CLI_RC_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/oci/ocirc"

# Oracle Cloud Functions
oci-who() {
  oci session authenticate
}

oci-list-compartments() {
  oci iam compartment list
}
{{ end -}}

{{ if .cloud.linode -}}
# Linode Configuration
export LINODE_CLI_CONFIG="${XDG_CONFIG_HOME:-$HOME/.config}/linode-cli"

# Linode Functions
linode-list() {
  linode-cli linodes list
}
{{ end -}}

# Common cloud functions
cloud-ip() {
  curl -s https://ifconfig.me
}

cloud-ports() {
  if [[ -z "$1" ]]; then
    echo "Usage: cloud-ports <host>"
    return 1
  fi
  nmap -Pn -p 1-1000 "$1"
}

# Terraform aliases and functions are in hashicorp_workflows.zsh.tmpl

# Kubernetes aliases and functions
{{ if .enable_kubernetes -}}
alias k='kubectl'
alias kgp='kubectl get pods'
alias kgs='kubectl get services'
alias kgd='kubectl get deployments'
alias kns='kubens'
alias kctx='kubectx'

# Switch Kubernetes context
kuse() {
  if [[ -z "$1" ]]; then
    kubectx
  else
    kubectx "$1"
  fi
}

# Switch Kubernetes namespace
kns-use() {
  if [[ -z "$1" ]]; then
    kubens
  else
    kubens "$1"
  fi
}

# Get pod logs
klogs() {
  kubectl logs -f "$1"
}

# Port forward to a pod
kforward() {
  kubectl port-forward "$1" "$2:$3"
}

# Execute command in pod
kexec() {
  kubectl exec -it "$1" -- "${@:2}"
}

# Get all resources
kgetall() {
  kubectl get all --all-namespaces
}
{{ end -}}
